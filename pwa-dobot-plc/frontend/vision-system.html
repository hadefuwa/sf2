<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8" />
 <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/apple-icon.png">
 <link rel="icon" type="image/png" href="/assets/img/favicon.png">
 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
 <title>Vision System - Smart Factory</title>
 <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, shrink-to-fit=no' name='viewport' />
 
 <!-- Fonts and icons -->
  <!-- Fonts and icons - all local (no internet required for HMI) -->
  <link rel="stylesheet" href="/assets/fontawesome/css/all.min.css">
 
 <!-- CSS Files -->
 <link href="/assets/css/material-dashboard.min.css?v=2.1.0" rel="stylesheet" />
 <link href="/assets/demo/demo.css" rel="stylesheet" />
 <link href="/assets/css/professional-theme.css" rel="stylesheet" />
 
 <!-- PWA Manifest -->
 <link rel="manifest" href="/manifest.json">
 <meta name="theme-color" content="#030c1d">
 <meta name="apple-mobile-web-app-capable" content="yes">
 <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

 <!-- All styles consolidated in professional-theme.css -->
</head>
<body class="dark-edition">
  <div class="wrapper ">
    <div class="sidebar" data-color="purple" data-background-color="black" data-image="">
      <div class="sidebar-animated-bg" id="sidebarAnimatedBg"></div>
      <div class="logo">
        <a href="/" class="simple-text logo-normal">
          <i class="material-icons">factory</i>
          Smart Factory
        </a>
      </div>
      <div class="sidebar-wrapper">
        <ul class="nav">
          <li class="nav-item">
            <a class="nav-link" href="/index.html">
              <i class="material-icons">dashboard</i>
              <p>Dashboard</p>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/robot-arm.html">
              <i class="material-icons">precision_manufacturing</i>
              <p>Robot Arm</p>
            </a>
          </li>
          <li class="nav-item active">
            <a class="nav-link" href="/vision-system.html">
              <i class="material-icons">visibility</i>
              <p>Vision System</p>
            </a>
          </li>

          <li class="nav-item">
            <a class="nav-link" href="/rfid.html">
              <i class="material-icons">nfc</i>
              <p>RFID Tracking</p>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/digital-twin.html">
              <i class="material-icons">view_in_ar</i>
              <p>Digital Twin</p>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/plc-diagnostics.html">
              <i class="material-icons">analytics</i>
              <p>PLC Diagnostics</p>
            </a>
          </li>
        </ul>
      </div>
    </div>

    <div class="main-panel">
      <!-- Navbar -->
      <nav class="navbar navbar-expand-lg navbar-transparent navbar-absolute fixed-top ">
        <div class="container-fluid">
          <div class="navbar-wrapper">
            <a class="navbar-brand" href="javascript:;">Vision System</a>
          </div>
          <button class="navbar-toggler" type="button" data-toggle="collapse" aria-controls="navigation-index" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="navbar-toggler-icon icon-bar"></span>
            <span class="navbar-toggler-icon icon-bar"></span>
            <span class="navbar-toggler-icon icon-bar"></span>
          </button>
          <div class="collapse navbar-collapse justify-content-end">
            <ul class="navbar-nav">
              <li class="nav-item">
                <a class="nav-link" href="javascript:;">
                  <i class="material-icons">notifications</i>
                  <p class="d-lg-none d-md-block">Notifications</p>
                </a>
              </li>
            </ul>
          </div>
        </div>
      </nav>
      <!-- End Navbar -->

      <div class="content">
        <div class="container-fluid">

 <!-- PLC Connection and Start Command Status Banner -->
 <div class="row"><div class="col-12">
 <div class="card"><div class="card-header card-header-info">
   <h4 class="card-title">Connection Status</h4>
 </div>
 <div class="card-body" style="padding: 16px 20px;">
 <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
 <!-- PLC Connection Status -->
 <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <span class="status-indicator" id="plcConnectionIndicator"></span>
 <div>
 <div style="color: var(--text-muted); font-size: 10px; margin-bottom: 4px;">PLC CONNECTION</div>
 <div id="plcConnectionText" style="color: var(--md-sys-color-on-surface-variant); font-size: 12px; font-weight: 600;">Loading...</div>
 </div>
 </div>

 <!-- DB123.40.0 Vision Start Bit Status -->
 <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <span class="status-indicator" id="db40StartIndicator"></span>
 <div>
 <div style="color: var(--text-muted); font-size: 10px; margin-bottom: 4px;">DB123.DBX40.0 VISION START</div>
 <div id="db40StartText" style="color: var(--md-sys-color-on-surface-variant); font-size: 12px; font-weight: 600;">Loading...</div>
 </div>
 </div>

 <!-- Override Start (bypasses PLC, 1 min timeout) -->
 <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <div>
 <div style="color: var(--text-muted); font-size: 10px; margin-bottom: 4px;">OVERRIDE START</div>
 <button type="button" class="btn btn-sm btn-warning" id="overrideStartBtn" onclick="setVisionOverride()" style="white-space: nowrap;">
 Override Start (1 min)
 </button>
 <div id="overrideCountdownText" style="color: var(--accent-green); font-size: 12px; font-weight: 600; margin-top: 4px; display: none;"></div>
 </div>
 </div>
 </div>
 </div><!-- close card-body -->
 </div><!-- close card -->
 </div></div><!-- close col / row -->

 <!-- Camera System -->
 <div class="row"><div class="col-12">
 <div class="card"><div class="card-header card-header-purple">
   <h4 class="card-title">Camera System</h4>
 </div>
 <div class="card-body" style="padding: 16px;">
 <div class="camera-section">
 <!-- Camera Viewer -->
 <div class="camera-viewer">
 <h3>Camera Feed</h3>
 <div class="camera-status">
 <span class="status-indicator" id="cameraStatusIndicator"></span>
 <span id="cameraStatusText">Disconnected</span>
 </div>
 <img id="cameraFrame" class="camera-frame" src="" alt="Camera Feed" style="display: none;">
 <div id="cameraPlaceholder" style="min-height: 300px; display: flex; align-items: center; justify-content: center; color: var(--text-muted); flex-direction: column; gap: 10px; background: rgba(10, 22, 40, 0.8); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <div style="font-size: 48px;">CAM</div>
 <div>Camera not connected</div>
 </div>
 <div class="camera-controls">
 <button class="btn btn-primary" id="connectCameraBtn" onclick="connectCamera()">
 <span>MON</span>
 <span>Connect</span>
 </button>
 <button class="btn btn-danger" id="disconnectCameraBtn" onclick="disconnectCamera()" disabled>
 <span>LIVE</span>
 <span>Disconnect</span>
 </button>
 <button class="btn btn-success" id="captureBtn" onclick="captureFrame()" disabled>
 <span>SNAP</span>
 <span>Capture</span>
 </button>
 <button class="btn btn-primary" id="processFrameBtn" onclick="processFrame()" disabled>
    <span>PROC</span>
    <span>Process Frame</span>
 </button>
 <button class="btn btn-primary" id="fullscreenBtn" onclick="toggleFullscreen()" disabled>
 <span>CROP</span>
 <span>Fullscreen</span>
 </button>
 <button class="btn btn-primary" id="settingsBtn" onclick="openCameraSettings()" disabled>
 <span>SET</span>
 <span>Settings</span>
 </button>
 </div>
 
 <!-- Image Adjustment Controls -->
 <div id="imageAdjustments" class="panel" style="display: none;">
 <h4>Image Adjustments</h4>
 <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
 <div>
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 11px; margin-bottom: 6px;">Brightness</label>
 <input type="range" id="brightnessSlider" min="-100" max="100" value="0" style="width: 100%;" oninput="updateImageAdjustments()">
 <span id="brightnessValue" style="color: var(--text-muted); font-size: 10px;">0</span>
 </div>
 <div>
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 11px; margin-bottom: 6px;">Contrast</label>
 <input type="range" id="contrastSlider" min="-100" max="100" value="0" style="width: 100%;" oninput="updateImageAdjustments()">
 <span id="contrastValue" style="color: var(--text-muted); font-size: 10px;">0</span>
 </div>
 </div>
 <button class="btn btn-primary" onclick="resetImageAdjustments()" style="margin-top: 12px; width: 100%; font-size: 11px; padding: 8px;">
 Reset Adjustments
 </button>
 </div>
 
 <!-- Camera Crop/Zoom Controls -->
 <div style="margin-top: 20px; padding: 16px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <h5 style="color: var(--md-sys-color-primary); font-size: 12px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px;">
 Camera Crop/Zoom
 </h5>
 <div style="margin-bottom: 12px;">
 <label style="display: flex; align-items: center; gap: 8px; color: var(--md-sys-color-on-surface-variant); font-size: 11px; cursor: pointer;">
 <input type="checkbox" id="cropEnabled" onchange="toggleCrop()" style="cursor: pointer;">
 <span>Enable Crop/Zoom</span>
 </label>
 </div>
 <div id="cropControls" style="display: none; grid-template-columns: 1fr 1fr; gap: 12px;">
 <div>
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 10px; margin-bottom: 4px;">X Position (%)</label>
 <input type="range" id="cropX" min="0" max="100" value="0" step="1" oninput="updateCropPreview()" style="width: 100%;">
 <div style="text-align: center; font-size: 10px; color: var(--md-sys-color-primary); margin-top: 4px;" id="cropXValue">0%</div>
 </div>
 <div>
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 10px; margin-bottom: 4px;">Y Position (%)</label>
 <input type="range" id="cropY" min="0" max="100" value="0" step="1" oninput="updateCropPreview()" style="width: 100%;">
 <div style="text-align: center; font-size: 10px; color: var(--md-sys-color-primary); margin-top: 4px;" id="cropYValue">0%</div>
 </div>
 <div>
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 10px; margin-bottom: 4px;">Width (%)</label>
 <input type="range" id="cropWidth" min="1" max="100" value="100" step="1" oninput="updateCropPreview()" style="width: 100%;">
 <div style="text-align: center; font-size: 10px; color: var(--md-sys-color-primary); margin-top: 4px;" id="cropWidthValue">100%</div>
 </div>
 <div>
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 10px; margin-bottom: 4px;">Height (%)</label>
 <input type="range" id="cropHeight" min="1" max="100" value="100" step="1" oninput="updateCropPreview()" style="width: 100%;">
 <div style="text-align: center; font-size: 10px; color: var(--md-sys-color-primary); margin-top: 4px;" id="cropHeightValue">100%</div>
 </div>
 </div>
 <div style="margin-top: 12px;">
 <button class="btn btn-primary" onclick="saveCropSettings()" style="font-size: 10px; padding: 6px 12px; width: 100%;">
 Save Crop Settings
 </button>
 </div>
 </div>
 </div>

 <!-- Analyzed Image Viewer -->
 <div class="camera-viewer">
 <h3>Analyzed Image</h3>
 <div class="camera-status">
 <span class="status-indicator" id="analyzedStatusIndicator"></span>
 <span id="analyzedStatusText">No analysis yet</span>
 </div>
 <img id="analyzedImage" class="camera-frame" src="" alt="Analyzed Image" style="display: none;">
 <div id="analyzedPlaceholder" style="min-height: 300px; display: flex; align-items: center; justify-content: center; color: var(--text-muted); flex-direction: column; gap: 10px; background: rgba(10, 22, 40, 0.8); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <div style="font-size: 48px;">SCAN</div>
 <div>Analysis results will appear here</div>
 </div>
 </div>
 </div><!-- close camera-section -->
 </div><!-- close card-body -->
 </div><!-- close card -->
 </div></div><!-- close col / row -->

 <!-- Detection & Analysis -->
 <div class="row"><div class="col-12">
 <div class="card"><div class="card-header card-header-success">
   <h4 class="card-title">Detection & Analysis</h4>
 </div>
 <div class="card-body" style="padding: 16px;">
 <div>
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- DETECTION METHOD SELECTOR - Clean, organized, dark mode optimized -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

<div style="background: linear-gradient(135deg, #1a1f3a 0%, #0f1419 100%); border: 3px solid #9c27b0; border-radius: 12px; padding: 20px; margin-bottom: 24px; box-shadow: 0 8px 32px rgba(156, 39, 176, 0.3);">
  
  <!-- ACTIVE METHOD DISPLAY - Big, obvious, easy to see -->
  <div style="text-align: center; margin-bottom: 20px; padding: 16px; background: rgba(156, 39, 176, 0.15); border-radius: 8px; border: 2px solid #9c27b0;">
    <div style="color: #9c27b0; font-size: 11px; font-weight: 600; letter-spacing: 1px; margin-bottom: 8px;">ACTIVE DETECTION METHOD</div>
    <div id="activeMethodDisplay" style="color: #ffffff; font-size: 24px; font-weight: 700; text-shadow: 0 2px 8px rgba(156, 39, 176, 0.5);">YOLO AI Model</div>
    <div id="activeMethodSubtext" style="color: #b39ddb; font-size: 12px; margin-top: 6px;">Neural network trained on your counters</div>
  </div>

  <!-- METHOD SELECTOR DROPDOWN -->
  <div style="margin-bottom: 20px;">
    <label style="display: block; color: #e0e0e0; font-size: 13px; font-weight: 600; margin-bottom: 10px;">
      <span style="color: #9c27b0;">‚óè</span> Choose Detection Method:
    </label>
    <select id="detectionMethodSelector" onchange="changeDetectionMethod()" style="
      width: 100%; 
      padding: 14px 16px; 
      background: #1e1e2e; 
      color: #ffffff; 
      border: 2px solid #424242; 
      border-radius: 8px; 
      font-size: 14px; 
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      outline: none;
    " onmouseover="this.style.borderColor='#9c27b0'" onmouseout="this.style.borderColor='#424242'">
      <option value="yolo" style="background: #1e1e2e; color: #ffffff; padding: 10px;">ü§ñ YOLO AI Model - Neural Network (Best Accuracy)</option>
      <option value="contour" style="background: #1e1e2e; color: #ffffff; padding: 10px;">üìê Contour Detection - Edge-based (Fast & Simple)</option>
      <option value="circle" style="background: #1e1e2e; color: #ffffff; padding: 10px;">‚≠ï Circle Detection - Hough Transform (For Round Objects)</option>
      <option value="blob" style="background: #1e1e2e; color: #ffffff; padding: 10px;">üîµ Blob Detection - Region-based (Very Fast)</option>
    </select>
  </div>

  <!-- METHOD INFO BOX -->
  <div id="detectionMethodInfo" style="
    color: #b0bec5; 
    font-size: 12px; 
    line-height: 1.6;
    padding: 14px; 
    background: rgba(0,0,0,0.4); 
    border-radius: 8px; 
    border-left: 4px solid #9c27b0;
    margin-bottom: 24px;
  ">
    <strong style="color: #ce93d8;">YOLO AI Model:</strong> Uses trained neural network. Best accuracy, requires model file. Adjust confidence and IOU below.
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- YOLO PARAMETERS - Only shown when YOLO is selected -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div id="yoloParams" style="display: block;">
    <div style="background: rgba(156, 39, 176, 0.1); border-radius: 8px; padding: 16px; border: 1px solid rgba(156, 39, 176, 0.3);">
      <h4 style="font-size: 14px; margin: 0 0 16px 0; color: #ce93d8; font-weight: 600; display: flex; align-items: center; gap: 8px;">
        <span style="color: #9c27b0;">‚öôÔ∏è</span> YOLO Parameters
      </h4>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
        <!-- Confidence -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Confidence Threshold
            <span id="yoloConfValue" style="float: right; color: #9c27b0; font-size: 13px; font-weight: 700;">0.15</span>
          </label>
          <input type="range" id="yoloConfSlider" min="0.05" max="0.50" step="0.05" value="0.15" oninput="updateYoloParams()" style="width: 100%; height: 6px; accent-color: #9c27b0;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Lower = more detections, Higher = fewer but confident</div>
        </div>

        <!-- IOU -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            IOU Threshold
            <span id="yoloIouValue" style="float: right; color: #9c27b0; font-size: 13px; font-weight: 700;">0.45</span>
          </label>
          <input type="range" id="yoloIouSlider" min="0.20" max="0.70" step="0.05" value="0.45" oninput="updateYoloParams()" style="width: 100%; height: 6px; accent-color: #9c27b0;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Controls duplicate box removal</div>
        </div>

        <!-- Crop Top -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Crop Top %
            <span id="yoloCropTopValue" style="float: right; color: #9c27b0; font-size: 13px; font-weight: 700;">0</span>
          </label>
          <input type="range" id="yoloCropTopSlider" min="0" max="50" step="5" value="0" oninput="updateYoloParams()" style="width: 100%; height: 6px; accent-color: #9c27b0;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Ignore top portion of frame</div>
        </div>

        <!-- Crop Bottom -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Crop Bottom %
            <span id="yoloCropBottomValue" style="float: right; color: #9c27b0; font-size: 13px; font-weight: 700;">0</span>
          </label>
          <input type="range" id="yoloCropBottomSlider" min="0" max="50" step="5" value="0" oninput="updateYoloParams()" style="width: 100%; height: 6px; accent-color: #9c27b0;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Ignore bottom portion of frame</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- SIMPLE DETECTION PARAMETERS - For Contour/Circle/Blob -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div id="simpleParams" style="display: none;">
    <div style="background: rgba(33, 150, 243, 0.1); border-radius: 8px; padding: 16px; border: 1px solid rgba(33, 150, 243, 0.3);">
      <h4 style="font-size: 14px; margin: 0 0 16px 0; color: #64b5f6; font-weight: 600; display: flex; align-items: center; gap: 8px;">
        <span style="color: #2196f3;">‚öôÔ∏è</span> Detection Parameters
      </h4>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
        <!-- Min Area -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Min Area (pixels)
            <span id="minAreaValue" style="float: right; color: #2196f3; font-size: 13px; font-weight: 700;">500</span>
          </label>
          <input type="range" id="minAreaSlider" min="100" max="5000" step="100" value="500" oninput="updateSimpleParams()" style="width: 100%; height: 6px; accent-color: #2196f3;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Minimum object size to detect</div>
        </div>

        <!-- Max Area -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Max Area (pixels)
            <span id="maxAreaValue" style="float: right; color: #2196f3; font-size: 13px; font-weight: 700;">50000</span>
          </label>
          <input type="range" id="maxAreaSlider" min="10000" max="100000" step="5000" value="50000" oninput="updateSimpleParams()" style="width: 100%; height: 6px; accent-color: #2196f3;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Maximum object size to detect</div>
        </div>

        <!-- Canny Low -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Edge Sensitivity (Low)
            <span id="cannyLowValue" style="float: right; color: #2196f3; font-size: 13px; font-weight: 700;">80</span>
          </label>
          <input type="range" id="cannyLowSlider" min="20" max="150" step="10" value="80" oninput="updateSimpleParams()" style="width: 100%; height: 6px; accent-color: #2196f3;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Lower = detect weaker edges</div>
        </div>

        <!-- Canny High -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Edge Sensitivity (High)
            <span id="cannyHighValue" style="float: right; color: #2196f3; font-size: 13px; font-weight: 700;">200</span>
          </label>
          <input type="range" id="cannyHighSlider" min="100" max="300" step="10" value="200" oninput="updateSimpleParams()" style="width: 100%; height: 6px; accent-color: #2196f3;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Higher = only strong edges</div>
        </div>

        <!-- Gaussian Blur -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Noise Reduction (Blur)
            <span id="gaussianBlurValue" style="float: right; color: #2196f3; font-size: 13px; font-weight: 700;">7</span>
          </label>
          <input type="range" id="gaussianBlurSlider" min="3" max="15" step="2" value="7" oninput="updateSimpleParams()" style="width: 100%; height: 6px; accent-color: #2196f3;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Higher = smoother, less noise</div>
        </div>

        <!-- Hough Threshold -->
        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;">
          <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">
            Circle Threshold
            <span id="houghThresholdValue" style="float: right; color: #2196f3; font-size: 13px; font-weight: 700;">80</span>
          </label>
          <input type="range" id="houghThresholdSlider" min="20" max="150" step="10" value="80" oninput="updateSimpleParams()" style="width: 100%; height: 6px; accent-color: #2196f3;">
          <div style="color: #757575; font-size: 9px; margin-top: 4px;">Lower = more circles detected</div>
        </div>
      </div>

      <!-- Reset Button -->
      <div style="margin-top: 16px; text-align: center;">
        <button class="btn btn-primary" onclick="resetSimpleParams()" style="padding: 10px 24px; font-size: 12px; font-weight: 600; border-radius: 6px;">
          üîÑ Reset to Defaults
        </button>
      </div>
    </div>
  </div>

</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

<!-- Detection Stats Display -->
<div id="objectDetectionStats" class="panel" style="display: block;">
<h4>Detection Results</h4>
<div style="display: flex; justify-content: space-between; margin-bottom: 12px; align-items: center;">
<span style="color: var(--md-sys-color-on-surface-variant); font-size: 13px; font-weight: 600;">Objects Detected:</span>
<span id="currentObjectCount" style="color: var(--accent-green); font-weight: 700; font-size: 20px;">0</span>
</div>
<div style="display: flex; justify-content: space-between; margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--border-color);">
<span style="color: var(--md-sys-color-on-surface-variant); font-size: 10px;">Last Updated:</span>
<span id="lastDetectionTime" style="color: var(--text-muted); font-size: 10px;">Never</span>
</div>
<div style="display: flex; justify-content: space-between; margin-top: 8px;">
<span style="color: var(--md-sys-color-on-surface-variant); font-size: 10px;">Method:</span>
<span id="currentMethodDisplay" style="color: var(--accent-green); font-size: 10px; font-weight: 600;">YOLO</span>
</div>
</div>
 
 <!-- Counter Timeline -->
 <div id="counterTimeline" class="panel" style="display: block;">
 <h4>Counter Detection Timeline</h4>
 <div id="counterTimelineList" style="max-height: 200px; overflow-y: auto;">
 <div style="color: var(--text-muted); text-align: center; padding: 12px; font-size: 11px;">No counters detected yet</div>
 </div>
 </div>
 
 <!-- Saved Counter Images Gallery -->
 <div id="counterImagesGallery" class="panel" style="display: block;">
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;">
 <h4 style="margin: 0;">Saved Counter Images</h4>
 <div style="display: flex; gap: 8px;">
 <button class="btn btn-danger" onclick="deleteAllCounterImages()" style="font-size: 10px; padding: 6px 10px;">
 DELETE Delete All
 </button>
 <button class="btn btn-primary" onclick="refreshCounterImages()" style="font-size: 10px; padding: 6px 10px;">
 REFRESH Refresh
 </button>
 </div>
 </div>
 <div id="counterImagesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px; max-height: 400px; overflow-y: auto;">
 <div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">Loading images...</div>
 </div>
 <div id="counterImagesStatus" style="margin-top: 8px; color: var(--text-muted); font-size: 10px;"></div>
 </div>
 
 <!-- Defect Detection Section -->
 <div id="defectDetectionSection" class="panel" style="display: block;">
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;">
 <h4 style="margin: 0;">Defect Detection</h4>
 <button class="btn btn-success" onclick="analyzeAllCountersForDefects()" style="font-size: 10px; padding: 6px 10px;">
 SCAN Analyze All
 </button>
 </div>
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 11px; margin-bottom: 12px;">
 Analyzes saved counter images to detect color changes on the counter surface
 </div>
 <div id="defectResultsList" style="max-height: 300px; overflow-y: auto;">
 <div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No defect analysis performed yet. Click "Analyze All" to check all counters.</div>
 </div>
 </div>

 <!-- PLC DB123 Configuration Section -->
 <div id="plcDb123ConfigSection" class="panel" style="display: block;">
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;">
 <h4 style="margin: 0;">PLC DB123 Communication Settings</h4>
 <button class="btn btn-primary" onclick="saveDb123Config()" style="font-size: 10px; padding: 6px 10px;">
 Save Settings
 </button>
 </div>
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 11px; margin-bottom: 16px;">
 Configure how vision detection results are written to Siemens PLC DB123 tags
 </div>
 
 <div style="margin-bottom: 16px;">
 <label style="display: flex; align-items: center; gap: 10px; color: var(--md-sys-color-on-surface-variant); font-size: 12px; cursor: pointer;">
 <input type="checkbox" id="db123Enabled" style="width: 16px; height: 16px; cursor: pointer; accent-color: var(--md-sys-color-primary);">
 <span>Enable DB123 Communication</span>
 </label>
 </div>

 <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px;">
 <div>
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 11px; margin-bottom: 6px;">DB Number</label>
 <input type="number" id="db123Number" value="123" min="1" max="65535" style="width: 100%; padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); color: var(--md-sys-color-on-surface); font-family: var(--font-mono); font-size: 12px;">
 </div>
 </div>

 <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color);">
 <h5 style="color: var(--md-sys-color-primary); font-size: 11px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px;">Tag Addresses (Read-Only Reference)</h5>
 <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px; color: var(--md-sys-color-on-surface-variant);">
 <div>Start: DB123.DBX40.0</div>
 <div>Connected: DB123.DBX40.1</div>
 <div>Busy: DB123.DBX40.2</div>
 <div>Completed: DB123.DBX40.3</div>
 <div>Object_Detected: DB123.DBX40.4</div>
 <div>Object_OK: DB123.DBX40.5</div>
 <div>Defect_Detected: DB123.DBX40.6</div>
 <div>Object_Number: DB123.DBW42</div>
 <div>Defect_Number: DB123.DBW44</div>
 </div>
 </div>

 <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color);">
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
 <h5 style="color: var(--md-sys-color-primary); font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin: 0;">Current Tag Status</h5>
 <button class="btn btn-primary" onclick="refreshPlcTags()" style="font-size: 9px; padding: 4px 8px;">
 REFRESH Refresh
 </button>
 </div>
 <div id="plcTagsStatus" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 10px;">
 <div style="color: var(--text-muted); text-align: center; padding: 12px; grid-column: 1 / -1;">Loading tag status...</div>
 </div>
 </div>

 <div style="margin-top: 16px; padding: 12px; background: rgba(0, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: 4px;">
 <div style="color: var(--md-sys-color-primary); font-size: 10px; font-weight: 700; margin-bottom: 6px;">Status:</div>
 <div id="db123Status" style="color: var(--md-sys-color-on-surface-variant); font-size: 10px;">Loading...</div>
 <div style="margin-top: 12px;">
 <button class="btn btn-primary" onclick="connectToPLC()" style="font-size: 10px; padding: 6px 12px; width: 100%;">
 Connect to PLC
 </button>
 </div>
 </div>
 
 <!-- Single Counter Detection Settings -->
 <div style="margin-top: 20px; padding: 16px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <h5 style="color: var(--md-sys-color-primary); font-size: 12px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px;">
 Single Counter Detection
 </h5>
 <div style="margin-bottom: 12px;">
 <label style="display: flex; align-items: center; gap: 8px; color: var(--md-sys-color-on-surface-variant); font-size: 11px; cursor: pointer;">
 <input type="checkbox" id="singleCounterEnabled" onchange="toggleSingleCounterSettings()" style="cursor: pointer;">
 <span>Enable Single Counter Mode (process only 1 counter when multiple detected)</span>
 </label>
 </div>
 <div id="singleCounterControls" style="display: none;">
 <div style="margin-bottom: 12px;">
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 10px; margin-bottom: 6px;">Selection Method</label>
 <select id="counterSelectionMethod" style="width: 100%; padding: 6px; background: var(--darker-bg); border: 1px solid var(--border-color); color: var(--md-sys-color-on-surface); font-size: 11px; border-radius: 4px;">
 <option value="most_central">Most Central (closest to center)</option>
 <option value="largest">Largest (biggest area)</option>
 <option value="smallest">Smallest (smallest area)</option>
 <option value="leftmost">Leftmost</option>
 <option value="rightmost">Rightmost</option>
 <option value="topmost">Topmost</option>
 <option value="bottommost">Bottommost</option>
 </select>
 </div>
 <div style="margin-bottom: 12px;">
 <label style="display: block; color: var(--md-sys-color-on-surface-variant); font-size: 10px; margin-bottom: 4px;">Position Matching Threshold (pixels)</label>
 <input type="number" id="positionThreshold" min="10" max="500" value="100" step="10" style="width: 100%; padding: 6px; background: var(--darker-bg); border: 1px solid var(--border-color); color: var(--md-sys-color-on-surface); font-size: 11px; border-radius: 4px;">
 <div style="font-size: 9px; color: var(--text-muted); margin-top: 4px;">Distance threshold for matching counters to existing positions</div>
 </div>
 </div>
 <div style="margin-top: 12px;">
 <button class="btn btn-primary" onclick="saveSingleCounterSettings()" style="font-size: 10px; padding: 6px 12px; width: 100%;">
 Save Settings
 </button>
 </div>
 </div>
 </div>

 <!-- Hidden inputs for method -->
 <input type="hidden" id="objectDetectionMethod" value="yolo">
 <input type="hidden" id="continuousObjectDetection" value="true">
 </div><!-- close detection inner wrapper -->
 </div><!-- close card-body -->
 </div><!-- close card -->
 </div></div><!-- close col / row -->

 <!-- Serial Monitor Log -->
 <div class="row"><div class="col-12">
 <div class="panel" style="margin-top: 0;">
 <h4 style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;" onclick="toggleSerialMonitor()">
 <span>
 <span id="serialMonitorToggleIcon">&#9654;</span> Serial Monitor Log
 </span>
 <button class="btn btn-primary" onclick="clearSerialLog(event)" style="font-size: 10px; padding: 6px 10px; margin: 0;">
 Clear Log
 </button>
 </h4>
 <div id="serialMonitor" style="display: none;">
 <div id="serialLog">
 <div style="color: var(--text-muted);">Vision System Serial Monitor - Ready</div>
 <div style="color: var(--text-muted);">Waiting for camera events...</div>
 </div>
 <div style="margin-top: 10px; display: flex; gap: 12px;">
 <label style="display: flex; align-items: center; gap: 8px; color: var(--md-sys-color-on-surface-variant); font-size: 11px; cursor: pointer;">
 <input type="checkbox" id="autoScrollLog" checked style="width: 14px; height: 14px; cursor: pointer; accent-color: var(--md-sys-color-primary);">
 <span>Auto-scroll</span>
 </label>
 <label style="display: flex; align-items: center; gap: 8px; color: var(--md-sys-color-on-surface-variant); font-size: 11px; cursor: pointer;">
 <input type="checkbox" id="timestampLog" checked style="width: 14px; height: 14px; cursor: pointer; accent-color: var(--md-sys-color-primary);">
 <span>Show timestamps</span>
 </label>
 </div>
 </div>
 </div><!-- close serial monitor panel -->
 </div></div><!-- close col / row -->

 <!-- Information Panel -->
 <div class="row"><div class="col-12">
 <div class="info-panel">
 <h3 onclick="toggleInfoPanel()">
 <span id="infoToggleIcon">&#9654;</span>
 <span>How the Vision System Works</span>
 </h3>
 <div id="infoContent" style="display: none;">
 <div style="color: var(--md-sys-color-on-surface-variant); line-height: 1.8; font-size: 13px;">
 <p style="margin-bottom: 16px;">
 Every second the camera grabs a snapshot, the YOLO microservice finds circular counters,
 the backend saves any new counters with a tight crop, and defect detection runs instantly.
 The timeline, saved image gallery, and defect list update themselves as soon as this happens.
 </p>

 <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">Camera Snapshots</h4>
 <ul style="margin-left: 24px; margin-bottom: 16px;">
 <li>USB camera (index 0) captures a JPEG every second at 640480</li>
 <li>The raw snapshot feeds the analyzed image and the saved counter crops</li>
 <li>The analyzed image you see is refreshed once per second (no stream required)</li>
 </ul>

 <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">Counter Tracking Flow</h4>
 <ol style="margin-left: 24px; margin-bottom: 16px;">
 <li><strong>YOLO Detection:</strong> Snapshot goes to the vision microservice (15% confidence, 0.45 IOU)</li>
 <li><strong>Position Matching:</strong> Each detection is compared with the last seen position so counters keep their number</li>
 <li><strong>Saving:</strong> New numbers trigger a tight crop (5 px padding) stored in <code style="background: var(--darker-bg); padding: 2px 6px; color: var(--md-sys-color-primary);">~/counter_images</code></li>
 <li><strong>Auto Defect Detection:</strong> Each saved image is analyzed right away; results are stored for the defect list</li>
 <li><strong>UI Update:</strong> Timeline, gallery, and defect panel pull the latest info every few seconds</li>
 </ol>

 <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">Automatic Defect Detection</h4>
 <ul style="margin-left: 24px; margin-bottom: 16px;">
 <li>When a counter image is saved, the backend isolates the circular surface and checks for color changes &gt; 110</li>
 <li>The stored defect results feed the "Defect Detection" card without needing to press "Analyze All"</li>
 <li>"Analyze All" simply re-runs checks if you want to doublecheck the latest images</li>
 </ul>

 <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">Resetting</h4>
 <ul style="margin-left: 24px; margin-bottom: 16px;">
 <li>The red "Delete All" button wipes saved images, defect data, and the detection timeline</li>
 <li>After deleting, the next detections start again at Counter 1</li>
 </ul>

 <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">Tips for Best Results</h4>
 <ul style="margin-left: 24px; margin-bottom: 16px;">
 <li>Keep lighting even so color-based defect checks stay accurate</li>
 <li>Use a contrasting belt color (blue works best for white counters)</li>
 <li>Keep counters fully in frame when you want them saved</li>
 <li>If YOLO misses one, move it back into frame; the number will be reused automatically</li>
 </ul>

 <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">Technical Notes</h4>
 <ul style="margin-left: 24px; margin-bottom: 16px;">
 <li>Backend: Flask + OpenCV + YOLO microservice (Ultralytics) managed by PM2</li>
 <li>Saved data lives in <code style="background: var(--darker-bg); padding: 2px 6px; color: var(--md-sys-color-primary);">~/counter_images</code> (images + JSON logs)</li>
 <li>All API routes are documented in <code style="background: var(--darker-bg); padding: 2px 6px; color: var(--md-sys-color-primary);">app.py</code> if you need custom tooling</li>
 </ul>
 </div>
 </div>
 </div>
 </div>
 </div>

        </div>
      </div>
    </div>
  </div>

  <!-- Core JS Files -->
  <script src="/assets/js/core/jquery.min.js"></script>
  <script src="/assets/js/core/popper.min.js"></script>
  <script src="/assets/js/core/bootstrap-material-design.min.js"></script>
  <script src="/assets/js/plugins/perfect-scrollbar.jquery.min.js"></script>
  <script src="/assets/js/material-dashboard.min.js?v=2.1.0" type="text/javascript"></script>

 <script>
 // Read a CSS custom property once and cache it
 const _themeCache = {};
 function theme(name) {
   if (!_themeCache[name]) _themeCache[name] = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
   return _themeCache[name];
 }

 // Global error handler for unhandled promise rejections
 window.addEventListener('unhandledrejection', function(event) {
 // Extract meaningful error message
 let errorMsg = 'Unhandled promise rejection';
 const error = event.reason;
 
 if (error instanceof Error) {
 errorMsg = error.message || error.name || 'Unknown error';
 } else if (typeof error === 'string') {
 errorMsg = error;
 } else if (error?.message) {
 errorMsg = error.message;
 }
 
 // Suppress timeout/abort errors as they're expected when backend is slow
 if (!errorMsg.includes('timeout') && !errorMsg.includes('aborted') && !errorMsg.includes('AbortError')) {
 console.error('Unhandled promise rejection:', errorMsg, error);
 }
 
 // Prevent default browser error logging for expected errors
 if (errorMsg.includes('timeout') || errorMsg.includes('aborted')) {
 event.preventDefault();
 }
 });
 
 const API_BASE = window.location.origin;
 console.log('Vision System v1.1 - API_BASE:', API_BASE);
 let cameraConnected = false;
 let streamInterval = null;
 let autoAnalyzeInterval = null;
 let autoAnalyzeActive = false;
 let objectDetectionInterval = null;
 let objectDetectionActive = false;
 let fullAnalysisInterval = null;
 let fullAnalysisActive = false;
 let counterImagesFirstLoad = true;
 // Override Start: bypasses PLC DB123.DBX40.0 check for 1 minute
 let visionOverrideActive = false;
 let visionOverrideTimeoutId = null;
 let visionOverrideCountdownIntervalId = null;
 let visionOverrideSecondsLeft = 0;

 window.addEventListener('load', () => {
 // Set up image event handlers
 const cameraFrame = document.getElementById('cameraFrame');
 if (cameraFrame) {
 cameraFrame.addEventListener('error', function() {
 handleStreamError(this);
 });
 cameraFrame.addEventListener('load', function() {
 handleStreamLoad(this);
 });
 }
 
 startStreamImmediately();
 loadDetectionParams();
 loadDb123Config();
 updatePlcTagsStatus();
 updatePlcConnectionStatus();
 updateDb40StartBit();
 loadCropSettings();
 loadSingleCounterSettings();
 topLevelObjectDetectionEnabled = true;
 objectDetectionEnabled = true;
 topLevelDefectDetectionEnabled = true;
 checkCameraStatus();
 setTimeout(() => {
 refreshCounterImages();
 updateCounterTimelineFromImages();
 setInterval(() => {
 refreshCounterImages();
 updateCounterTimelineFromImages();
 }, 15000);
 }, 1000);
 setTimeout(() => {
 addSerialLog('Vision System initialized', 'info');
 addSerialLog('Camera stream starting immediately', 'info');
 addSerialLog('Object detection enabled by default', 'info');
 
 // Initialize detection method selector
 const methodSelector = document.getElementById('detectionMethodSelector');
 if (methodSelector) {
 const hiddenInput = document.getElementById('objectDetectionMethod');
 if (hiddenInput && hiddenInput.value) {
 methodSelector.value = hiddenInput.value;
 }
 // Trigger initial info display
 changeDetectionMethod();
 }
 
 // Initialize parameter sliders with current values
 document.getElementById('yoloConfSlider').value = objectParams.conf;
 document.getElementById('yoloIouSlider').value = objectParams.iou;
 document.getElementById('yoloCropTopSlider').value = objectParams.crop_top_percent;
 document.getElementById('yoloCropBottomSlider').value = objectParams.crop_bottom_percent;
 document.getElementById('yoloConfValue').textContent = objectParams.conf.toFixed(2);
 document.getElementById('yoloIouValue').textContent = objectParams.iou.toFixed(2);
 document.getElementById('yoloCropTopValue').textContent = objectParams.crop_top_percent;
 document.getElementById('yoloCropBottomValue').textContent = objectParams.crop_bottom_percent;
 
 document.getElementById('minAreaSlider').value = detectionParams.min_area;
 document.getElementById('maxAreaSlider').value = detectionParams.max_area;
 document.getElementById('cannyLowSlider').value = detectionParams.canny_low;
 document.getElementById('cannyHighSlider').value = detectionParams.canny_high;
 document.getElementById('gaussianBlurSlider').value = detectionParams.gaussian_blur;
 document.getElementById('houghThresholdSlider').value = detectionParams.hough_threshold;
 document.getElementById('minAreaValue').textContent = detectionParams.min_area;
 document.getElementById('maxAreaValue').textContent = detectionParams.max_area;
 document.getElementById('cannyLowValue').textContent = detectionParams.canny_low;
 document.getElementById('cannyHighValue').textContent = detectionParams.canny_high;
 document.getElementById('gaussianBlurValue').textContent = detectionParams.gaussian_blur;
 document.getElementById('houghThresholdValue').textContent = detectionParams.hough_threshold;
 addSerialLog('Background subtraction enabled for conveyor belt detection', 'info');
 addSerialLog('Auto-analysis will start automatically when camera connects', 'info');
 addSerialLog('Serial monitor ready', 'info');
 }, 500);
 setTimeout(() => {
 if (cameraConnected && !objectDetectionActive) {
 const continuousCheckbox = document.getElementById('continuousObjectDetection');
 if (continuousCheckbox) continuousCheckbox.checked = true;
 startObjectDetection();
 }
 }, 2000);
 });

 async function checkCameraStatus() {
 try {
 const response = await fetch(`${API_BASE}/api/camera/status`);
 const data = await response.json();
 if (data.connected) {
 updateCameraStatus(true);
 startStream();
 setTimeout(() => {
 if (!objectDetectionActive) {
 const continuousCheckbox = document.getElementById('continuousObjectDetection');
 if (continuousCheckbox) continuousCheckbox.checked = true;
 startObjectDetection();
 }
 }, 1000);
 } else {
 updateCameraStatus(false);
 }
 } catch (error) {
 console.error('Error checking camera status:', error);
 updateCameraStatus(false);
 }
 }

 let detectionHistory = [];
 let currentResults = null;
 const counterFirstAppearance = {};

 function updateCameraStatus(connected) {
 cameraConnected = connected;
 const indicator = document.getElementById('cameraStatusIndicator');
 const statusText = document.getElementById('cameraStatusText');
 const connectBtn = document.getElementById('connectCameraBtn');
 const disconnectBtn = document.getElementById('disconnectCameraBtn');
 const captureBtn = document.getElementById('captureBtn');
 const processFrameBtn = document.getElementById('processFrameBtn');
 const fullscreenBtn = document.getElementById('fullscreenBtn');
 const settingsBtn = document.getElementById('settingsBtn');
 const frame = document.getElementById('cameraFrame');
 const placeholder = document.getElementById('cameraPlaceholder');

 if (connected) {
 indicator.classList.add('connected');
 statusText.textContent = 'Connected';
 if (connectBtn) connectBtn.disabled = true;
 if (disconnectBtn) disconnectBtn.disabled = false;
 if (captureBtn) captureBtn.disabled = false;
 if (processFrameBtn) processFrameBtn.disabled = false;
 if (fullscreenBtn) fullscreenBtn.disabled = false;
 if (settingsBtn) settingsBtn.disabled = false;
 if (frame) frame.style.display = 'block';
 if (placeholder) placeholder.style.display = 'none';
 addSerialLog('Camera status: CONNECTED', 'camera');
 } else {
 indicator.classList.remove('connected');
 statusText.textContent = 'Disconnected';
 if (connectBtn) connectBtn.disabled = false;
 if (disconnectBtn) disconnectBtn.disabled = true;
 if (captureBtn) captureBtn.disabled = true;
 if (processFrameBtn) processFrameBtn.disabled = true;
 if (fullscreenBtn) fullscreenBtn.disabled = true;
 if (settingsBtn) settingsBtn.disabled = true;
 if (frame) frame.style.display = 'none';
 if (placeholder) placeholder.style.display = 'flex';
 stopStream();
 addSerialLog('Camera status: DISCONNECTED', 'camera');
 }
 }

 async function connectCamera() {
 try {
 const response = await fetch(`${API_BASE}/api/camera/connect`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ index: 0, width: 640, height: 480 })
 });
 const data = await response.json();
 if (data.success) {
 updateCameraStatus(true);
 startStream();
 setTimeout(() => {
 if (!objectDetectionActive) {
 const continuousCheckbox = document.getElementById('continuousObjectDetection');
 if (continuousCheckbox) continuousCheckbox.checked = true;
 startObjectDetection();
 }
 }, 1500);
 } else {
 alert('Failed to connect camera: ' + (data.error || 'Unknown error'));
 }
 } catch (error) {
 console.error('Error connecting camera:', error);
 alert('Error connecting camera: ' + error.message);
 }
 }

 async function disconnectCamera() {
 try {
 addSerialLog('Disconnecting camera...', 'camera');
 await fetch(`${API_BASE}/api/camera/disconnect`, { method: 'POST' });
 updateCameraStatus(false);
 if (objectDetectionActive) stopObjectDetection();
 if (fullAnalysisActive) stopFullAnalysis();
 addSerialLog('Camera disconnected', 'info');
 } catch (error) {
 console.error('Error disconnecting camera:', error);
 addSerialLog(`Camera disconnect error: ${error.message}`, 'error');
 }
 }

 function startStream() {
 if (streamInterval) return;
 const frame = document.getElementById('cameraFrame');
 frame.style.display = 'block';
 const placeholder = document.getElementById('cameraPlaceholder');
 if (placeholder) placeholder.style.display = 'none';
 addSerialLog('Camera snapshot mode started (2 second interval - reduced to prevent resource exhaustion)', 'camera');
 updateCameraSnapshot();
 // Increased from 1000ms to 2000ms to reduce request load
 streamInterval = setInterval(() => {
 if (cameraConnected) {
 updateCameraSnapshot();
 } else {
 stopStream();
 }
 }, 2000); // Changed from 1000 to 2000ms
 }

 // Camera snapshot request throttling
 let isFetchingCamera = false;

 async function updateCameraSnapshot() {
 // Skip if previous fetch still in progress
 if (isFetchingCamera) {
 console.log('Camera fetch already in progress, skipping...');
 return;
 }

 isFetchingCamera = true;
 try {
 const frame = document.getElementById('cameraFrame');
 const response = await fetch(`${API_BASE}/api/camera/capture?t=${Date.now()}`, {
 signal: AbortSignal.timeout(10000) // 10 second timeout (camera operations can be slow)
 });
 
 if (response.ok) {
 const blob = await response.blob();
 const url = URL.createObjectURL(blob);
 if (frame.src && frame.src.startsWith('blob:')) {
 URL.revokeObjectURL(frame.src);
 }
 frame.src = url;
 frame.style.display = 'block';
 const placeholder = document.getElementById('cameraPlaceholder');
 if (placeholder) placeholder.style.display = 'none';
 } else {
 // Handle HTTP errors (camera not connected, etc.)
 const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
 console.warn(`Camera snapshot failed (${response.status}): ${errorData.error}`);
 
 // If camera not opened/connected, stop trying and show placeholder
 if (response.status === 503 || errorData.error?.includes('not opened')) {
 cameraConnected = false;
 stopStream();
 const placeholder = document.getElementById('cameraPlaceholder');
 if (placeholder) {
 placeholder.style.display = 'flex';
 placeholder.innerHTML = '<div style="text-align:center"><i class="material-icons" style="font-size:48px;color:#f44336;">videocam_off</i><p style="margin-top:10px;color:#fff;">Camera Not Connected</p><p style="font-size:12px;color:#999;">Click Connect Camera to start</p></div>';
 }
 frame.style.display = 'none';
 addSerialLog('Camera disconnected - snapshot stopped', 'error');
 }
 }
 } catch (error) {
 // Extract meaningful error message
 let errorMsg = 'Unknown error';
 if (error instanceof Error) {
 errorMsg = error.message || error.name || 'Unknown error';
 } else if (typeof error === 'string') {
 errorMsg = error;
 } else if (error?.message) {
 errorMsg = error.message;
 }
 
 // Don't log timeout/abort errors as they're expected when backend is slow
 if (!errorMsg.includes('timeout') && !errorMsg.includes('aborted') && !errorMsg.includes('AbortError')) {
 console.error('Error updating camera snapshot:', errorMsg);
 addSerialLog(`Camera error: ${errorMsg}`, 'error');
 }
 } finally {
 isFetchingCamera = false; // Always release lock
 }
 }

 function stopStream() {
 if (streamInterval) {
 clearInterval(streamInterval);
 streamInterval = null;
 }
 const frame = document.getElementById('cameraFrame');
 if (frame.src && frame.src.startsWith('blob:')) {
 URL.revokeObjectURL(frame.src);
 }
 frame.src = '';
 addSerialLog('Camera snapshot stopped', 'camera');
 }

 function startStreamImmediately() {
 const frame = document.getElementById('cameraFrame');
 frame.style.display = 'block';
 const placeholder = document.getElementById('cameraPlaceholder');
 if (placeholder) placeholder.style.display = 'none';
 addSerialLog('Starting camera snapshot mode (2 second interval - optimized)', 'camera');
 startStream();
 }

 function handleStreamLoad(imgElement) {
 const placeholder = document.getElementById('cameraPlaceholder');
 if (placeholder) placeholder.style.display = 'none';
 imgElement.style.display = 'block';
 }

 async function captureFrame() {
 try {
 addSerialLog('Capturing frame...', 'camera');
 const response = await fetch(`${API_BASE}/api/camera/capture?t=${Date.now()}`);
 if (response.ok) {
 const blob = await response.blob();
 const url = URL.createObjectURL(blob);
 const link = document.createElement('a');
 link.href = url;
 link.download = `capture-${Date.now()}.jpg`;
 link.click();
 URL.revokeObjectURL(url);
 addSerialLog('Frame captured and saved', 'success');
 } else {
 addSerialLog('Frame capture failed', 'error');
 }
 } catch (error) {
 console.error('Error capturing frame:', error);
 addSerialLog(`Frame capture error: ${error.message}`, 'error');
 alert('Error capturing frame: ' + error.message);
 }
 }

 async function processFrame() {
    try {
        addSerialLog('Manually processing frame...', 'camera');
        const response = await fetch(`${API_BASE}/api/vision/process-manual`, { method: 'POST' });
        if (response.ok) {
            const data = await response.json();
            addSerialLog(data.message, 'success');
        } else {
            addSerialLog('Failed to start manual processing', 'error');
        }
    } catch (error) {
        console.error('Error processing frame:', error);
        addSerialLog(`Error processing frame: ${error.message}`, 'error');
        alert('Error processing frame: ' + error.message);
    }
 }

 function toggleObjectDetection() {
 objectDetectionEnabled = topLevelObjectDetectionEnabled;
 if (objectDetectionEnabled) {
 addSerialLog('Object detection enabled', 'info');
 } else {
 addSerialLog('Object detection disabled', 'info');
 }
 }

 async function startObjectDetection() {
 if (objectDetectionActive) return;
 objectDetectionActive = true;
 const startBtn = document.getElementById('startObjectDetectionBtn');
 const stopBtn = document.getElementById('stopObjectDetectionBtn');
 const statsDiv = document.getElementById('objectDetectionStats');
 if (startBtn) startBtn.style.display = 'none';
 if (stopBtn) stopBtn.style.display = 'inline-flex';
 if (statsDiv) statsDiv.style.display = 'block';
 addSerialLog('Object detection started (continuous mode)', 'detection');
 const continuousCheckbox = document.getElementById('continuousObjectDetection');
 const continuous = continuousCheckbox ? continuousCheckbox.checked : true;
 await detectObjectsOnly();
 if (continuous) {
 objectDetectionInterval = setInterval(async () => {
 if (objectDetectionActive && cameraConnected) {
 await detectObjectsOnly();
 }
 }, 1000);
 }
 }

 function stopObjectDetection() {
 objectDetectionActive = false;
 const startBtn = document.getElementById('startObjectDetectionBtn');
 const stopBtn = document.getElementById('stopObjectDetectionBtn');
 if (startBtn) startBtn.style.display = 'inline-flex';
 if (stopBtn) stopBtn.style.display = 'none';
 addSerialLog('Object detection stopped', 'detection');
 if (objectDetectionInterval) {
 clearInterval(objectDetectionInterval);
 objectDetectionInterval = null;
 }
 }

 let topLevelObjectDetectionEnabled = true;
 let topLevelDefectDetectionEnabled = true;
 let objectDetectionEnabled = true;
 
 // YOLO parameters (now mutable for real-time adjustment)
 let objectParams = {
 conf: 0.15,
 iou: 0.45,
 crop_top_percent: 0,
 crop_bottom_percent: 0
 };

 let detectionParams = {
 min_area: 500,
 max_area: 50000,
 blob_min_area: 500,
 blob_max_area: 20000,
 contour_min_area: 1000,
 contour_max_area: 50000,
 canny_low: 80,
 canny_high: 200,
 edge_canny_low: 60,
 edge_canny_high: 150,
 hough_threshold: 80,
 merge_threshold: 50,
 gaussian_blur: 7,
 adaptive_thresh_block: 15,
 adaptive_thresh_c: 5,
 min_line_length: 50,
 max_line_gap: 20,
 line_grouping_distance: 50,
 min_lines_per_defect: 3,
 min_edge_defect_size: 30,
 aspect_ratio_min: 0.3,
 aspect_ratio_max: 3.0,
 dilation_iterations: 1,
 morphological_kernel_size: 3
 };

 async function detectObjectsOnly() {
 try {
 // Check if PLC Start command is active before processing
 const configResponse = await fetch(`${API_BASE}/api/config`);
 const config = await configResponse.json();
 const db123Config = config.plc?.db123 || {};
 
 if (visionOverrideActive) {
 addSerialLog('Override active - bypassing PLC Start check', 'info');
 } else if (db123Config.enabled) {
 // DB123 is enabled - check Start command
 const tagsResponse = await fetch(`${API_BASE}/api/plc/db123/read`);
 if (tagsResponse.ok) {
 const tagsData = await tagsResponse.json();
 const startCommand = tagsData.tags?.start || false;

 addSerialLog(` Checking Start command: ${startCommand ? 'TRUE' : 'FALSE'}`, 'info');

 if (!startCommand) {
 // Start command is False - skip detection
 addSerialLog('Detection skipped - PLC Start command not active', 'warning');
 return;
 }

 addSerialLog('Start command is TRUE - proceeding with detection', 'success');
 } else {
 // Can't read tags - skip to be safe
 const errorText = await tagsResponse.text();
 addSerialLog(` Detection skipped - Cannot read PLC tags: ${tagsResponse.status} - ${errorText}`, 'warning');
 return;
 }
 } else {
 addSerialLog('DB123 disabled - allowing detection (testing mode)', 'info');
 }
 // If override active or DB123 disabled or Start TRUE: allow processing
 
 const objectMethodElement = document.getElementById('objectDetectionMethod');
 const objectMethod = objectMethodElement ? objectMethodElement.value : 'yolo';
 
 // Log which detection method is being used
 const methodNames = {
 'yolo': 'YOLO AI Model',
 'contour': 'Simple Contour Detection',
 'circle': 'Circle Detection (Hough)',
 'blob': 'Blob Detection'
 };
 const methodName = methodNames[objectMethod] || objectMethod;
 addSerialLog(`Running detection: ${methodName}`, 'detection');
 
 // Log parameters based on method
 if (objectMethod === 'yolo') {
 addSerialLog(` Params: Confidence=${objectParams.conf}, IOU=${objectParams.iou}`, 'info');
 } else {
 addSerialLog(` Params: Using default ${objectMethod} parameters`, 'info');
 }
 const captureResponse = await fetch(`${API_BASE}/api/vision/analyze`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 method: 'combined',
 params: detectionParams,
 use_object_detection: true,
 object_method: objectMethod,
 object_params: objectParams,
 defect_detection_enabled: false
 })
 });
 
 if (captureResponse.status === 403) {
 // Start command not active - backend rejected the request
 const errorText = await captureResponse.text();
 let errorData;
 try {
 errorData = JSON.parse(errorText);
 } catch (e) {
 errorData = { message: errorText };
 }
 addSerialLog(` ${errorData.message || 'PLC Start command not active'}`, 'warning');
 return;
 }
 
 if (!captureResponse.ok) {
 addSerialLog(`Analysis API error: ${captureResponse.status}`, 'error');
 return;
 }
 
 const blob = await captureResponse.blob();
 const url = URL.createObjectURL(blob);
 const analyzedImg = document.getElementById('analyzedImage');
 const analyzedPlaceholder = document.getElementById('analyzedPlaceholder');
 if (analyzedImg.src && analyzedImg.src.startsWith('blob:')) {
 URL.revokeObjectURL(analyzedImg.src);
 }
 analyzedImg.src = url;
 analyzedImg.style.display = 'block';
 analyzedPlaceholder.style.display = 'none';
 const analyzedStatusIndicator = document.getElementById('analyzedStatusIndicator');
 const analyzedStatusText = document.getElementById('analyzedStatusText');
 if (analyzedStatusIndicator) analyzedStatusIndicator.classList.add('connected');
 if (analyzedStatusText) analyzedStatusText.textContent = 'Analysis Complete';
 
 const detectResponse = await fetch(`${API_BASE}/api/vision/detect`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 object_detection_enabled: true,
 defect_detection_enabled: false,
 object_method: objectMethod,
 object_params: objectParams
 })
 });
 
 if (detectResponse.status === 403) {
 // Start command not active - backend rejected the request
 const errorText = await detectResponse.text();
 let errorData;
 try {
 errorData = JSON.parse(errorText);
 } catch (e) {
 errorData = { message: errorText };
 }
 addSerialLog(` ${errorData.message || 'PLC Start command not active'}`, 'warning');
 return;
 }
 
 if (detectResponse.ok) {
 const results = await detectResponse.json();
 const objectCount = results.object_count || 0;
 const objects = results.objects || [];
 addSerialLog(`Detection results: ${objectCount} counters found`, 'detection');
 
 if (objects.length > 0) {
 objects.forEach((obj, idx) => {
 const methodUsed = obj.method || objectMethod || 'unknown';
 addSerialLog(` Counter ${idx + 1}: center=(${obj.center[0]},${obj.center[1]}), radius=${obj.radius || 'N/A'}px, area=${obj.area?.toFixed(0) || 'N/A'}px, confidence=${(obj.confidence * 100).toFixed(0) || 'N/A'}%, method=${methodUsed}`, 'detection');
 });
 } else {
 addSerialLog('No counters detected - check camera view and lighting', 'warning');
 }
 
 // Log settings based on method used
 if (objectMethod === 'yolo') {
 addSerialLog(` YOLO settings: Confidence=${objectParams.conf}, IOU=${objectParams.iou}`, 'info');
 } else {
 addSerialLog(` Detection method: ${objectMethod}`, 'info');
 }
 
 const statsDiv = document.getElementById('objectDetectionStats');
 if (statsDiv) statsDiv.style.display = 'block';
 const countElement = document.getElementById('currentObjectCount');
 const timeElement = document.getElementById('lastDetectionTime');
 if (countElement) countElement.textContent = objectCount;
 if (timeElement) timeElement.textContent = new Date().toLocaleTimeString();
 if (countElement) {
 if (objectCount === 4) {
 countElement.style.color = theme('--status-success');
 } else if (objectCount > 4) {
 countElement.style.color = theme('--status-warning');
 } else {
 countElement.style.color = theme('--status-danger');
 }
 }
 updateCounterTimelineFromImages();
 addSerialLog(`Counter detection complete: Found ${objectCount} counters`, objectCount > 0 ? 'info' : 'detection');
 } else {
 const errorText = await detectResponse.text();
 addSerialLog(`Detection API error: ${detectResponse.status} - ${errorText}`, 'error');
 }
 } catch (error) {
 console.error('Error in object detection:', error);
 addSerialLog(`Object detection error: ${error.message}`, 'error');
 }
 }

 async function startFullAnalysis() {
 addSerialLog('Full analysis is no longer available - use continuous object detection instead', 'info');
 }

 function stopFullAnalysis() {
 fullAnalysisActive = false;
 if (fullAnalysisInterval) {
 clearInterval(fullAnalysisInterval);
 fullAnalysisInterval = null;
 }
 addSerialLog('Full analysis stopped', 'info');
 }

 async function updateCounterTimelineFromImages() {
 const timelineList = document.getElementById('counterTimelineList');
 if (!timelineList) return;
 try {
 const response = await fetch(`${API_BASE}/api/counter-images`);
 const data = await response.json();
 if (data.error) {
 timelineList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 12px; font-size: 11px;">No counters detected yet</div>';
 return;
 }
 const images = data.images || [];
 if (images.length === 0) {
 timelineList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 12px; font-size: 11px;">No counters detected yet</div>';
 return;
 }
 const counterMap = {};
 images.forEach(img => {
 const counterNum = img.counter_number;
 if (!counterMap[counterNum] || new Date(img.timestamp) < new Date(counterMap[counterNum].timestamp)) {
 counterMap[counterNum] = img;
 }
 });
 const counterNumbers = Object.keys(counterMap).map(Number).sort((a, b) => a - b);
 timelineList.innerHTML = counterNumbers.map(counterNum => {
 const img = counterMap[counterNum];
 const date = new Date(img.timestamp * 1000);
 const formattedTime = date.toLocaleString();
 return `
 <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
 <span style="color: var(--md-sys-color-primary); font-weight: 700; font-size: 12px;">Counter ${counterNum}</span>
 <span style="color: var(--text-muted); font-size: 10px;">${formattedTime}</span>
 </div>
 `;
 }).join('');
 } catch (error) {
 console.error('Error updating counter timeline:', error);
 timelineList.innerHTML = '<div style="color: var(--accent-red); text-align: center; padding: 12px; font-size: 11px;">Error loading timeline</div>';
 }
 }

 async function deleteAllCounterImages() {
 if (!confirm('Are you sure you want to delete all counter images and reset the timeline? This cannot be undone.')) {
 return;
 }
 try {
 addSerialLog('Deleting all counter images and resetting timeline...', 'info');
 const response = await fetch(`${API_BASE}/api/counter-images/delete-all`, { method: 'POST' });
 const data = await response.json();
 if (data.error) {
 addSerialLog(`Error deleting images: ${data.error}`, 'error');
 alert(`Error: ${data.error}`);
 return;
 }
 addSerialLog(`Successfully deleted ${data.deleted || 0} counter images and reset counter tracker`, 'success');
 await refreshCounterImages();
 await updateCounterTimelineFromImages();
 const defectResultsList = document.getElementById('defectResultsList');
 if (defectResultsList) {
 defectResultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No defect analysis performed yet. Click "Analyze All" to check all counters.</div>';
 }
 } catch (error) {
 console.error('Error deleting counter images:', error);
 addSerialLog(`Error deleting images: ${error.message}`, 'error');
 alert(`Error: ${error.message}`);
 }
 }

 async function refreshCounterImages() {
 const imagesList = document.getElementById('counterImagesList');
 const statusDiv = document.getElementById('counterImagesStatus');
 if (!imagesList) return;
 try {
 if (counterImagesFirstLoad) {
 imagesList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">Loading images...</div>';
 if (statusDiv) statusDiv.textContent = '';
 } else if (statusDiv) {
 statusDiv.textContent = 'Refreshing...';
 }
 const response = await fetch(`${API_BASE}/api/counter-images`);
 const data = await response.json();
 if (data.error) {
 if (counterImagesFirstLoad) {
 imagesList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">Error: ${data.error}</div>`;
 }
 if (statusDiv) statusDiv.textContent = `Error: ${data.error}`;
 return;
 }
 const images = data.images || [];
 if (images.length === 0) {
 imagesList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">No counter images saved yet</div>';
 if (statusDiv) statusDiv.textContent = 'Waiting for new counter images...';
 counterImagesFirstLoad = false;
 loadStoredDefectResults();
 return;
 }
 imagesList.innerHTML = images.map(img => {
 return `
 <div style="background: var(--md-sys-color-surface-container-low); padding: 10px; border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px; cursor: pointer; transition: all 0.3s;" onclick="openImageModal('${img.url}')" onmouseover="this.style.borderColor='var(--md-sys-color-primary)'" onmouseout="this.style.borderColor='var(--md-sys-color-outline-variant)'">
 <img src="${img.url}" alt="Counter ${img.counter_number}" style="width: 100%; height: 120px; object-fit: cover; margin-bottom: 8px;">
 <div style="color: var(--md-sys-color-primary); font-weight: 700; font-size: 10px; margin-bottom: 4px;">Counter ${img.counter_number}</div>
 <div style="color: var(--text-muted); font-size: 9px;">${img.formatted_time}</div>
 </div>
 `;
 }).join('');
 addSerialLog(`Loaded ${images.length} counter images`, 'info');
 counterImagesFirstLoad = false;
 if (statusDiv) statusDiv.textContent = `Updated at ${new Date().toLocaleTimeString()}`;
 loadStoredDefectResults();
 } catch (error) {
 console.error('Error loading counter images:', error);
 if (counterImagesFirstLoad) {
 imagesList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">Error loading images: ${error.message}</div>`;
 }
 if (statusDiv) statusDiv.textContent = `Error loading images: ${error.message}`;
 }
 }

 // Minimum thresholds for displaying defects (filter out false positives)
 const DEFECT_MIN_CONFIDENCE = 30; // Minimum 30% confidence
 const DEFECT_MIN_COVERAGE = 5; // Minimum 5% coverage
 
 async function loadStoredDefectResults() {
 const resultsList = document.getElementById('defectResultsList');
 if (!resultsList) return;
 try {
 addSerialLog('=== Loading Stored Defect Results ===', 'detection');
 addSerialLog(`Thresholds: Min Confidence=${DEFECT_MIN_CONFIDENCE}%, Min Coverage=${DEFECT_MIN_COVERAGE}%`, 'info');
 
 // First, get the list of actual saved counter images
 const imagesResponse = await fetch(`${API_BASE}/api/counter-images`);
 const imagesData = await imagesResponse.json();
 const savedCounterNumbers = new Set();
 if (imagesData.images && imagesData.images.length > 0) {
 imagesData.images.forEach(img => savedCounterNumbers.add(img.counter_number));
 }
 
 addSerialLog(`Saved counter images: [${[...savedCounterNumbers].sort((a,b) => a-b).join(', ')}] (${savedCounterNumbers.size} total)`, 'info');
 
 // If no saved images, don't show any defect results
 if (savedCounterNumbers.size === 0) {
 addSerialLog('No saved images found - skipping defect display', 'warning');
 resultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No counter images to analyze</div>';
 return;
 }
 
 // Now get the defect results
 const response = await fetch(`${API_BASE}/api/counter-images/defects`);
 const data = await response.json();
 if (data.error) {
 addSerialLog(`Defect API error: ${data.error}`, 'error');
 resultsList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px;">Error loading defect results: ${data.error}</div>`;
 return;
 }
 const defects = data.defects || [];
 addSerialLog(`Raw defect results from API: ${defects.length} entries`, 'info');
 
 if (defects.length === 0) {
 addSerialLog('No defect analysis data in storage', 'info');
 resultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No defect analysis results yet</div>';
 return;
 }
 
 // Log all raw defect data for debugging
 addSerialLog('--- Raw Defect Data ---', 'detection');
 defects.forEach(result => {
 const defectData = result.defect_results || {};
 const confidence = defectData.confidence || 0;
 const coverage = defectData.total_defect_area_percentage || 0;
 const defectsFound = defectData.defects_found || false;
 const hasImage = savedCounterNumbers.has(result.counter_number);
 
 addSerialLog(` Counter ${result.counter_number}: defects_found=${defectsFound}, confidence=${confidence.toFixed(1)}%, coverage=${coverage.toFixed(1)}%, has_saved_image=${hasImage}`, 'info');
 
 if (defectData.defects && defectData.defects.length > 0) {
 defectData.defects.forEach((d, i) => {
 addSerialLog(` Defect ${i+1}: area=${(d.area_percentage || 0).toFixed(1)}%, color_diff=${d.color_difference || 0}`, 'info');
 });
 }
 });
 
 // Filter defects to only include:
 // 1. Counters that have saved images
 // 2. Defects with confidence >= DEFECT_MIN_CONFIDENCE
 // 3. Defects with coverage >= DEFECT_MIN_COVERAGE
 addSerialLog('--- Filtering Results ---', 'detection');
 const validDefects = defects.filter(result => {
 const counterNum = result.counter_number;
 const defectData = result.defect_results || {};
 const confidence = defectData.confidence || 0;
 const coverage = defectData.total_defect_area_percentage || 0;
 
 // Must have a saved image
 if (!savedCounterNumbers.has(counterNum)) {
 addSerialLog(` Counter ${counterNum}: FILTERED - no saved image`, 'warning');
 return false;
 }
 
 if (!defectData.defects_found) {
 addSerialLog(` Counter ${counterNum}: SKIPPED - no defects detected by backend`, 'info');
 return false;
 }
 
 // Check confidence threshold
 if (confidence < DEFECT_MIN_CONFIDENCE) {
 addSerialLog(` Counter ${counterNum}: FILTERED - confidence ${confidence.toFixed(1)}% < ${DEFECT_MIN_CONFIDENCE}% threshold`, 'warning');
 return false;
 }
 
 // Check coverage threshold
 if (coverage < DEFECT_MIN_COVERAGE) {
 addSerialLog(` Counter ${counterNum}: FILTERED - coverage ${coverage.toFixed(1)}% < ${DEFECT_MIN_COVERAGE}% threshold`, 'warning');
 return false;
 }
 
 addSerialLog(` Counter ${counterNum}: PASSED - showing defect (conf=${confidence.toFixed(1)}%, cov=${coverage.toFixed(1)}%)`, 'success');
 return true;
 });
 
 addSerialLog(`Final: ${validDefects.length} of ${defects.length} defects passed filters`, 'detection');
 
 if (validDefects.length === 0) {
 addSerialLog('No defects passed thresholds - all counters appear good', 'success');
 resultsList.innerHTML = '<div style="color: var(--accent-green); text-align: center; padding: 24px; font-size: 11px;"> No significant defects found - all counters are good!</div>';
 return;
 }
 
 resultsList.innerHTML = validDefects
 .sort((a, b) => a.counter_number - b.counter_number)
 .map(result => {
 const data = result.defect_results || {};
 return `
 <div style="background: var(--md-sys-color-surface-container-low); padding: 12px; margin-bottom: 10px; border-left: 3px solid var(--status-error); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
 <div style="color: var(--md-sys-color-primary); font-weight: 700; font-size: 11px;">Counter ${result.counter_number}</div>
 <div style="color: var(--accent-red); font-weight: 700; font-size: 10px;">DEFECT FOUND</div>
 </div>
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 10px;">
 Coverage: ${data.total_defect_area_percentage ? data.total_defect_area_percentage.toFixed(1) : '0'}% | Confidence: ${data.confidence ? data.confidence.toFixed(1) : '0.0'}%
 </div>
 </div>
 `;
 }).join('');
 } catch (error) {
 console.error('Error loading stored defect results:', error);
 resultsList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px;">Error loading defect results: ${error.message}</div>`;
 }
 }

 function openImageModal(imageUrl) {
 const modal = document.createElement('div');
 modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 0, 21, 0.95); z-index: 10000; display: flex; align-items: center; justify-content: center; cursor: pointer;';
 modal.onclick = () => document.body.removeChild(modal);
 const img = document.createElement('img');
 img.src = imageUrl;
 img.style.cssText = 'max-width: 90%; max-height: 90%; object-fit: contain; border: 2px solid var(--border-color);';
 img.onclick = (e) => e.stopPropagation();
 modal.appendChild(img);
 document.body.appendChild(modal);
 }

 async function analyzeAllCountersForDefects() {
 const resultsList = document.getElementById('defectResultsList');
 if (!resultsList) return;
 try {
 addSerialLog('=== ANALYZE ALL COUNTERS FOR DEFECTS ===', 'detection');
 addSerialLog(`Thresholds: Min Confidence=${DEFECT_MIN_CONFIDENCE}%, Min Coverage=${DEFECT_MIN_COVERAGE}%`, 'info');
 
 resultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">Analyzing counters for defects...</div>';
 const imagesResponse = await fetch(`${API_BASE}/api/counter-images`);
 const imagesData = await imagesResponse.json();
 if (imagesData.error || !imagesData.images || imagesData.images.length === 0) {
 addSerialLog('No counter images found to analyze', 'warning');
 resultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No counter images to analyze</div>';
 return;
 }
 
 addSerialLog(`Found ${imagesData.images.length} counter images to analyze`, 'info');
 
 const analysisResults = [];
 for (const img of imagesData.images) {
 try {
 addSerialLog(`Analyzing Counter ${img.counter_number}...`, 'detection');
 const response = await fetch(`${API_BASE}/api/counter-images/${img.counter_number}/analyze-defects`, { method: 'POST' });
 const result = await response.json();
 result.counter_number = img.counter_number;
 analysisResults.push(result);
 
 // Log detailed results
 const confidence = result.confidence || 0;
 const coverage = result.total_defect_area_percentage || 0;
 const defectCount = result.defect_count || 0;
 
 addSerialLog(` Counter ${img.counter_number} result:`, 'info');
 addSerialLog(` defects_found: ${result.defects_found}`, 'info');
 addSerialLog(` defect_count: ${defectCount}`, 'info');
 addSerialLog(` confidence: ${confidence.toFixed(1)}%`, 'info');
 addSerialLog(` coverage: ${coverage.toFixed(1)}%`, 'info');
 
 if (result.defects && result.defects.length > 0) {
 result.defects.forEach((d, i) => {
 addSerialLog(` Defect ${i+1}: area=${(d.area_percentage || 0).toFixed(1)}%, color_diff=${d.color_difference || 0}, center=(${d.center_x || 0},${d.center_y || 0})`, 'info');
 });
 }
 
 // Log raw API response for deep debugging
 addSerialLog(` Raw API response keys: ${Object.keys(result).join(', ')}`, 'info');
 
 } catch (error) {
 console.error(`Error analyzing counter ${img.counter_number}:`, error);
 addSerialLog(` Counter ${img.counter_number}: ERROR - ${error.message}`, 'error');
 analysisResults.push({ counter_number: img.counter_number, error: error.message });
 }
 }
 
 // Filter to only show significant defects (above thresholds)
 addSerialLog('--- Filtering Results ---', 'detection');
 const significantDefects = analysisResults.filter(result => {
 const counterNum = result.counter_number;
 
 if (result.error) {
 addSerialLog(` Counter ${counterNum}: FILTERED - analysis error`, 'error');
 return false;
 }
 
 if (!result.defects_found) {
 addSerialLog(` Counter ${counterNum}: SKIPPED - no defects detected by backend`, 'info');
 return false;
 }
 
 const confidence = result.confidence || 0;
 const coverage = result.total_defect_area_percentage || 0;
 
 if (confidence < DEFECT_MIN_CONFIDENCE) {
 addSerialLog(` Counter ${counterNum}: FILTERED - confidence ${confidence.toFixed(1)}% < ${DEFECT_MIN_CONFIDENCE}% threshold`, 'warning');
 return false;
 }
 
 if (coverage < DEFECT_MIN_COVERAGE) {
 addSerialLog(` Counter ${counterNum}: FILTERED - coverage ${coverage.toFixed(1)}% < ${DEFECT_MIN_COVERAGE}% threshold`, 'warning');
 return false;
 }
 
 addSerialLog(` Counter ${counterNum}: PASSED - showing defect (conf=${confidence.toFixed(1)}%, cov=${coverage.toFixed(1)}%)`, 'success');
 return true;
 });
 
 addSerialLog(`=== SUMMARY ===`, 'detection');
 addSerialLog(`Total analyzed: ${analysisResults.length}`, 'info');
 addSerialLog(`Passed filters: ${significantDefects.length}`, 'info');
 addSerialLog(`Filtered out: ${analysisResults.length - significantDefects.length}`, 'info');
 
 if (significantDefects.length === 0) {
 resultsList.innerHTML = '<div style="color: var(--accent-green); text-align: center; padding: 24px; font-size: 11px;"> No significant defects found - all counters are good!</div>';
 addSerialLog(`No significant defects passed thresholds`, 'success');
 return;
 }
 
 resultsList.innerHTML = significantDefects
 .sort((a, b) => a.counter_number - b.counter_number)
 .map(result => {
 return `
 <div style="background: var(--md-sys-color-surface-container-low); padding: 12px; margin-bottom: 10px; border-left: 3px solid var(--status-error); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 8px;">
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
 <div style="color: var(--md-sys-color-primary); font-weight: 700; font-size: 11px;">Counter ${result.counter_number}</div>
 <div style="color: var(--accent-red); font-weight: 700; font-size: 10px;">DEFECT FOUND</div>
 </div>
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 10px;">
 Coverage: ${result.total_defect_area_percentage ? result.total_defect_area_percentage.toFixed(1) : '0'}% | Confidence: ${(result.confidence || 0).toFixed(1)}%
 </div>
 </div>
 `;
 }).join('');
 addSerialLog(`${significantDefects.length} counters with significant defects displayed`, 'detection');
 } catch (error) {
 console.error('Error analyzing counters for defects:', error);
 addSerialLog(`Fatal error in defect analysis: ${error.message}`, 'error');
 resultsList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px;">Error: ${error.message}</div>`;
 }
 }

 function toggleInfoPanel() {
 const content = document.getElementById('infoContent');
 const icon = document.getElementById('infoToggleIcon');
 if (content.style.display === 'none') {
 content.style.display = 'block';
 icon.textContent = '';
 } else {
 content.style.display = 'none';
 icon.textContent = '';
 }
 }

 function toggleFullscreen() {
 const frame = document.getElementById('cameraFrame');
 if (!frame.src) return;
 if (!document.fullscreenElement) {
 frame.requestFullscreen().catch(err => alert('Error entering fullscreen: ' + err.message));
 } else {
 document.exitFullscreen();
 }
 }

 // Camera Crop/Zoom Functions
 async function loadCropSettings() {
 try {
 const response = await fetch(`${API_BASE}/api/camera/crop`);
 if (response.ok) {
 const crop = await response.json();
 document.getElementById('cropEnabled').checked = crop.enabled;
 document.getElementById('cropX').value = crop.x;
 document.getElementById('cropY').value = crop.y;
 document.getElementById('cropWidth').value = crop.width;
 document.getElementById('cropHeight').value = crop.height;
 
 toggleCrop();
 updateCropPreview();
 } else {
 console.warn('Failed to load crop settings:', response.status);
 }
 } catch (error) {
 console.error('Error loading crop settings:', error);
 // Don't show error to user - just use defaults
 }
 }
 
 function toggleCrop() {
 const enabled = document.getElementById('cropEnabled').checked;
 const controls = document.getElementById('cropControls');
 controls.style.display = enabled ? 'grid' : 'none';
 if (!enabled) {
 // Reset to full frame when disabled
 document.getElementById('cropX').value = 0;
 document.getElementById('cropY').value = 0;
 document.getElementById('cropWidth').value = 100;
 document.getElementById('cropHeight').value = 100;
 updateCropPreview();
 }
 }
 
 function updateCropPreview() {
 const x = document.getElementById('cropX').value;
 const y = document.getElementById('cropY').value;
 const width = document.getElementById('cropWidth').value;
 const height = document.getElementById('cropHeight').value;
 
 document.getElementById('cropXValue').textContent = x + '%';
 document.getElementById('cropYValue').textContent = y + '%';
 document.getElementById('cropWidthValue').textContent = width + '%';
 document.getElementById('cropHeightValue').textContent = height + '%';
 }
 
 async function saveCropSettings() {
 try {
 const enabled = document.getElementById('cropEnabled').checked;
 const x = parseFloat(document.getElementById('cropX').value);
 const y = parseFloat(document.getElementById('cropY').value);
 const width = parseFloat(document.getElementById('cropWidth').value);
 const height = parseFloat(document.getElementById('cropHeight').value);
 
 const response = await fetch(`${API_BASE}/api/camera/crop`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ enabled, x, y, width, height })
 });
 
 if (response.ok) {
 addSerialLog('Crop settings saved successfully', 'success');
 // Force refresh camera feed
 if (cameraConnected) {
 updateCameraSnapshot();
 }
 } else {
 const error = await response.json();
 addSerialLog(` Error saving crop: ${error.error || 'Unknown error'}`, 'error');
 }
 } catch (error) {
 console.error('Error saving crop settings:', error);
 addSerialLog(` Error saving crop: ${error.message}`, 'error');
 }
 }
 
 // Single Counter Detection Settings Functions
 async function loadSingleCounterSettings() {
 try {
 const response = await fetch(`${API_BASE}/api/config`);
 if (response.ok) {
 const config = await response.json();
 const visionConfig = config.vision || {};
 
 document.getElementById('singleCounterEnabled').checked = visionConfig.single_counter_enabled !== false; // Default true
 document.getElementById('counterSelectionMethod').value = visionConfig.counter_selection_method || 'most_central';
 document.getElementById('positionThreshold').value = visionConfig.position_matching_threshold || 100;
 
 toggleSingleCounterSettings();
 }
 } catch (error) {
 console.error('Error loading single counter settings:', error);
 }
 }
 
 function toggleSingleCounterSettings() {
 const enabled = document.getElementById('singleCounterEnabled').checked;
 const controls = document.getElementById('singleCounterControls');
 controls.style.display = enabled ? 'block' : 'none';
 }
 
 async function saveSingleCounterSettings() {
 try {
 const enabled = document.getElementById('singleCounterEnabled').checked;
 const method = document.getElementById('counterSelectionMethod').value;
 const threshold = parseInt(document.getElementById('positionThreshold').value);
 
 const response = await fetch(`${API_BASE}/api/config`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 vision: {
 single_counter_enabled: enabled,
 counter_selection_method: method,
 position_matching_threshold: threshold
 }
 })
 });
 
 if (response.ok) {
 addSerialLog('Single counter settings saved successfully', 'success');
 } else {
 const error = await response.json();
 addSerialLog(` Error saving settings: ${error.error || 'Unknown error'}`, 'error');
 }
 } catch (error) {
 console.error('Error saving single counter settings:', error);
 addSerialLog(` Error saving settings: ${error.message}`, 'error');
 }
 }
 
 function openCameraSettings() {
 const adjustments = document.getElementById('imageAdjustments');
 if (adjustments.style.display === 'none') {
 adjustments.style.display = 'block';
 } else {
 adjustments.style.display = 'none';
 }
 }

 function updateImageAdjustments() {
 const brightness = document.getElementById('brightnessSlider').value;
 const contrast = document.getElementById('contrastSlider').value;
 const frame = document.getElementById('cameraFrame');
 document.getElementById('brightnessValue').textContent = brightness;
 document.getElementById('contrastValue').textContent = contrast;
 const brightnessValue = parseFloat(brightness) / 100;
 const contrastValue = (parseFloat(contrast) + 100) / 100;
 frame.style.filter = `brightness(${1 + brightnessValue}) contrast(${contrastValue})`;
 }

 function resetImageAdjustments() {
 document.getElementById('brightnessSlider').value = 0;
 document.getElementById('contrastSlider').value = 0;
 document.getElementById('brightnessValue').textContent = '0';
 document.getElementById('contrastValue').textContent = '0';
 const frame = document.getElementById('cameraFrame');
 frame.style.filter = 'none';
 }

 function loadDetectionParams() {
 const saved = localStorage.getItem('detectionParams');
 if (saved) {
 try {
 detectionParams = JSON.parse(saved);
 } catch (e) {
 console.error('Error loading detection params:', e);
 }
 }
 }

 function toggleSerialMonitor() {
 const monitor = document.getElementById('serialMonitor');
 const icon = document.getElementById('serialMonitorToggleIcon');
 if (monitor.style.display === 'none') {
 monitor.style.display = 'block';
 icon.textContent = '';
 } else {
 monitor.style.display = 'none';
 icon.textContent = '';
 }
 }

 let serialLogEntries = [];
 const MAX_LOG_ENTRIES = 500;

 function addSerialLog(message, type = 'info') {
 const now = new Date();
 serialLogEntries.push({ message, type, timestamp: now });
 if (serialLogEntries.length > MAX_LOG_ENTRIES) {
 serialLogEntries.shift();
 }
 updateSerialLogDisplay();
 }

 function updateSerialLogDisplay() {
 const logDiv = document.getElementById('serialLog');
 if (!logDiv) return;
 
 // Store scroll position BEFORE updating content
 const autoScrollEnabled = document.getElementById('autoScrollLog')?.checked ?? true;
 const previousScrollTop = logDiv.scrollTop;
 const previousScrollHeight = logDiv.scrollHeight;
 
 const timestamp = document.getElementById('timestampLog')?.checked ?? true;
 const colors = {
 'info':      theme('--status-info'),
 'warning':   theme('--status-warning'),
 'error':     theme('--status-danger'),
 'success':   theme('--status-success'),
 'camera':    '#22d3ee',
 'detection': '#2dd4bf',
 'plc':       theme('--status-warning')
 };
 let html = '';
 serialLogEntries.forEach(entry => {
 const timeStr = timestamp ? `[${entry.timestamp.toLocaleTimeString()}.${String(entry.timestamp.getMilliseconds()).padStart(3, '0')}] ` : '';
 const color = colors[entry.type] || theme('--text-muted');
 html += `<div style="color: ${color};">${timeStr}${entry.message}</div>`;
 });
 logDiv.innerHTML = html || '<div class="log-placeholder">No log entries</div>';
 
 // Restore scroll position AFTER content update
 if (autoScrollEnabled) {
 // Auto-scroll: always go to bottom
 setTimeout(() => {
 logDiv.scrollTop = logDiv.scrollHeight;
 }, 10);
 } else {
 // Manual scroll: preserve exact scroll position (don't move user)
 // Calculate the ratio of scroll position to maintain relative position
 const scrollRatio = previousScrollHeight > 0 ? previousScrollTop / previousScrollHeight : 0;
 setTimeout(() => {
 // Restore to same relative position, but clamp to valid range
 const newScrollTop = Math.min(
 logDiv.scrollHeight * scrollRatio,
 logDiv.scrollHeight - logDiv.clientHeight
 );
 logDiv.scrollTop = Math.max(0, newScrollTop);
 }, 10);
 }
 }

 function clearSerialLog(event) {
 if (event) event.stopPropagation();
 serialLogEntries = [];
 updateSerialLogDisplay();
 addSerialLog('Serial monitor cleared', 'info');
 }

 // DB123 Configuration Functions
 async function loadDb123Config() {
 try {
 const response = await fetch(`${API_BASE}/api/config`);
 const config = await response.json();
 const db123Config = config.plc?.db123 || {};
 
 const enabledCheckbox = document.getElementById('db123Enabled');
 const dbNumberInput = document.getElementById('db123Number');
 const statusDiv = document.getElementById('db123Status');
 
 if (enabledCheckbox) {
 enabledCheckbox.checked = db123Config.enabled || false;
 }
 if (dbNumberInput) {
 dbNumberInput.value = db123Config.db_number || 123;
 }
 
 updateDb123Status();
 } catch (error) {
 console.error('Error loading DB123 config:', error);
 addSerialLog(`Error loading DB123 config: ${error.message}`, 'error');
 }
 }

 async function saveDb123Config() {
 try {
 const enabledCheckbox = document.getElementById('db123Enabled');
 const dbNumberInput = document.getElementById('db123Number');
 
 const enabled = enabledCheckbox ? enabledCheckbox.checked : false;
 const dbNumber = dbNumberInput ? parseInt(dbNumberInput.value) : 123;
 
 if (isNaN(dbNumber) || dbNumber < 1 || dbNumber > 65535) {
 alert('DB Number must be between 1 and 65535');
 return;
 }
 
 addSerialLog('Saving DB123 configuration...', 'info');
 
 const response = await fetch(`${API_BASE}/api/config`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 plc: {
 db123: {
 enabled: enabled,
 db_number: dbNumber
 }
 }
 })
 });
 
 const result = await response.json();
 if (result.success) {
 addSerialLog('DB123 configuration saved successfully', 'success');
 updateDb123Status();
 alert('DB123 configuration saved successfully!');
 } else {
 addSerialLog(`Error saving DB123 config: ${result.error || 'Unknown error'}`, 'error');
 alert(`Error: ${result.error || 'Failed to save configuration'}`);
 }
 } catch (error) {
 console.error('Error saving DB123 config:', error);
 addSerialLog(`Error saving DB123 config: ${error.message}`, 'error');
 alert(`Error saving configuration: ${error.message}`);
 }
 }

 async function updateDb123Status() {
 const statusDiv = document.getElementById('db123Status');
 if (!statusDiv) return;

 try {
 const configResponse = await fetch(`${API_BASE}/api/config`, {
 signal: AbortSignal.timeout(10000) // 10 second timeout (PLC operations can be slow)
 });
 const config = await configResponse.json();
 const db123Config = config.plc?.db123 || {};
 const enabled = db123Config.enabled || false;
 const dbNumber = db123Config.db_number || 123;

 // Get PLC connection status from API
 let plcConnected = false;
 try {
 const plcStatusResponse = await fetch(`${API_BASE}/api/plc/status`, {
 signal: AbortSignal.timeout(10000) // 10 second timeout (PLC operations can be slow)
 });
 const plcStatus = await plcStatusResponse.json();
 plcConnected = plcStatus.connected || false;
 } catch (e) {
 // If PLC status endpoint fails, assume disconnected
 plcConnected = false;
 }
 
 if (enabled) {
 statusDiv.innerHTML = `
 <div style="color: var(--accent-green);"> DB123 Communication: ENABLED</div>
 <div style="color: var(--md-sys-color-on-surface-variant); margin-top: 4px;">DB Number: ${dbNumber}</div>
 <div style="color: ${plcConnected ? 'var(--accent-green)' : 'var(--accent-red)'}; margin-top: 4px;">
 PLC Connection: ${plcConnected ? 'Connected' : 'Disconnected'}
 </div>
 `;
 } else {
 statusDiv.innerHTML = `
 <div style="color: var(--text-muted);">DB123 Communication: DISABLED</div>
 <div style="color: var(--md-sys-color-on-surface-variant); margin-top: 4px; font-size: 9px;">Enable the checkbox above to start writing to PLC</div>
 `;
 }
 } catch (error) {
 statusDiv.innerHTML = `<div style="color: var(--accent-red);">Error loading status: ${error.message}</div>`;
 }
 }

 // Request throttling: Track ongoing requests to prevent overlaps
 let isUpdatingStatus = false;

 // Coordinated status update - runs every 3 seconds, updates all status info sequentially
 async function updateAllStatus() {
 if (isUpdatingStatus) {
 console.log('Status update already in progress, skipping...');
 return; // Skip if previous update still running
 }

 isUpdatingStatus = true;
 try {
 // Update sequentially to avoid overloading browser connection pool
 await updatePlcTagsStatus();
 await new Promise(resolve => setTimeout(resolve, 100)); // 100ms delay between requests
 await updatePlcConnectionStatus();
 await new Promise(resolve => setTimeout(resolve, 100));
 await updateDb40StartBit();
 await new Promise(resolve => setTimeout(resolve, 100));
 await updateDb123Status();
 } catch (error) {
 // Extract meaningful error message
 let errorMsg = 'Unknown error';
 if (error instanceof Error) {
 errorMsg = error.message || error.name || 'Unknown error';
 } else if (typeof error === 'string') {
 errorMsg = error;
 } else if (error?.message) {
 errorMsg = error.message;
 }

 // Only log if it's not a timeout (timeouts are expected when backend is slow)
 if (!errorMsg.includes('timeout') && !errorMsg.includes('aborted')) {
 console.error('Error in updateAllStatus:', errorMsg, error);
 }
 } finally {
 isUpdatingStatus = false;
 }
 }

 // Initial update
 updateAllStatus();

 // Update all status every 3 seconds (reduced from 2s to prevent resource exhaustion)
 setInterval(updateAllStatus, 3000);

 // PLC Connection Functions
 async function connectToPLC() {
 try {
 addSerialLog('Attempting to connect to PLC...', 'plc');
 const response = await fetch(`${API_BASE}/api/plc/connect`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' }
 });
 const result = await response.json();
 
 if (result.success && result.connected) {
 addSerialLog('PLC connected successfully', 'success');
 updateDb123Status();
 updatePlcTagsStatus();
 alert('PLC connected successfully!');
 } else {
 addSerialLog(` PLC connection failed: ${result.error || 'Unknown error'}`, 'error');
 alert(`PLC connection failed: ${result.error || 'Unknown error'}\n\nCheck:\n- PLC is powered on\n- Network connectivity (ping 192.168.7.2)\n- PLC PUT/GET communication is enabled in TIA Portal`);
 }
 } catch (error) {
 console.error('Error connecting to PLC:', error);
 addSerialLog(`PLC connection error: ${error.message}`, 'error');
 alert(`Error connecting to PLC: ${error.message}`);
 }
 }

 // PLC Tags Status Functions
 // Helper function for timeout (works in all browsers)
 function fetchWithTimeout(url, options = {}, timeout = 10000) {
 return Promise.race([
 fetch(url, options).catch(error => {
 // Wrap fetch errors with more context
 if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
 throw new Error(`Network error: Cannot reach ${url}. Check if backend is running.`);
 }
 throw error;
 }),
 new Promise((_, reject) => 
 setTimeout(() => reject(new Error(`Request timeout after ${timeout}ms: ${url}`)), timeout)
 )
 ]);
 }

 async function updatePlcTagsStatus() {
 const tagsDiv = document.getElementById('plcTagsStatus');
 if (!tagsDiv) return;

 // Default tags to show if everything fails
 const defaultTags = {
 'start': false,
 'connected': false,
 'busy': false,
 'completed': false,
 'object_detected': false,
 'object_ok': false,
 'defect_detected': false,
 'object_number': 0,
 'defect_number': 0
 };

 try {
 // SIMPLE: Just read tags, no timeouts, no complex error handling
 const response = await fetch(`${API_BASE}/api/plc/db123/read`);
 const data = response.ok ? await response.json() : { tags: defaultTags };
 const tags = data.tags || defaultTags;
 
 // Helper function to format boolean values
 const formatBool = (value) => {
 if (value === true || value === 1) {
 return '<span style="color: var(--accent-green); font-weight: 700;">TRUE</span>';
 } else {
 return '<span style="color: var(--text-muted);">FALSE</span>';
 }
 };
 
 tagsDiv.innerHTML = `
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Start</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${formatBool(tags.start)}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.0</div>
 </div>
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Connected</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${formatBool(tags.connected)}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.1</div>
 </div>
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Busy</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${formatBool(tags.busy)}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.2</div>
 </div>
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Completed</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${formatBool(tags.completed)}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.3</div>
 </div>
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Object_Detected</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${formatBool(tags.object_detected)}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.4</div>
 </div>
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Object_OK</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${formatBool(tags.object_ok)}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.5</div>
 </div>
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Defect_Detected</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${formatBool(tags.defect_detected)}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.6</div>
 </div>
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Object_Number</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${tags.object_number || 0}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBW42</div>
 </div>
 <div style="padding: 8px; background: var(--md-sys-color-surface-container); border: 1px solid var(--md-sys-color-outline-variant); border-radius: 6px;">
 <div style="color: var(--md-sys-color-on-surface-variant); font-size: 9px; margin-bottom: 4px;">Defect_Number</div>
 <div style="color: var(--md-sys-color-primary); font-size: 11px; font-weight: 700;">${tags.defect_number || 0}</div>
 <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBW44</div>
 </div>
 `;
 } catch (error) {
 console.error('Error updating PLC tags status:', error);
 let errorMsg = error.message || 'Unknown error';
 if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
 errorMsg = 'Backend server not responding - check if app is running';
 }
 tagsDiv.innerHTML = `
 <div style="color: var(--accent-red); text-align: center; padding: 12px; grid-column: 1 / -1;">
 Error loading tags: ${errorMsg}
 </div>
 `;
 }
 }

 async function refreshPlcTags() {
 addSerialLog('Refreshing PLC tag status...', 'plc');
 await updatePlcTagsStatus();
 }

 // Helper function to safely update status text
 function updateStatusText(element, html) {
 if (!element) return;
 try {
 element.innerHTML = html;
 } catch (e) {
 console.error('Error updating status text:', e);
 element.textContent = html.replace(/<[^>]*>/g, ''); // Strip HTML as fallback
 }
 }

 // PLC Connection Status Functions
 async function updatePlcConnectionStatus() {
 const indicator = document.getElementById('plcConnectionIndicator');
 const statusText = document.getElementById('plcConnectionText');

 if (!indicator || !statusText) {
 console.error('[PLC Connection] Elements not found!');
 return;
 }

 try {
 // Get PLC status
 const response = await fetch(`${API_BASE}/api/plc/status`, {
 signal: AbortSignal.timeout(5000)
 });

 if (!response.ok) {
 throw new Error(`HTTP ${response.status}`);
 }

 const data = await response.json();
 const connected = data.connected || false;

 if (connected) {
 indicator.classList.add('connected');
 updateStatusText(statusText, `<span style="color: var(--accent-green);"> Connected to ${data.ip || '192.168.7.2'}</span>`);
 } else {
 indicator.classList.remove('connected');
 const error = data.last_error || 'Not connected';
 updateStatusText(statusText, `<span style="color: var(--accent-red);"> Disconnected</span><br><span style="font-size: 10px; color: var(--text-muted);">${error}</span>`);
 }
 } catch (error) {
 console.error('[PLC Connection] Error:', error);
 indicator.classList.remove('connected');
 let errorMsg = error.message || 'Unknown error';
 if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
 errorMsg = 'Backend not responding';
 }
 updateStatusText(statusText, `<span style="color: var(--accent-red);"> Error</span><br><span style="font-size: 10px; color: var(--text-muted);">${errorMsg}</span>`);
 }
 }

 // Override Start: bypass PLC check for 1 minute, then auto-clear
 const OVERRIDE_DURATION_SECONDS = 60;

 function clearVisionOverride() {
 visionOverrideActive = false;
 visionOverrideSecondsLeft = 0;
 if (visionOverrideTimeoutId) {
 clearTimeout(visionOverrideTimeoutId);
 visionOverrideTimeoutId = null;
 }
 if (visionOverrideCountdownIntervalId) {
 clearInterval(visionOverrideCountdownIntervalId);
 visionOverrideCountdownIntervalId = null;
 }
 const btn = document.getElementById('overrideStartBtn');
 const countdownEl = document.getElementById('overrideCountdownText');
 if (btn) {
 btn.disabled = false;
 btn.textContent = 'Override Start (1 min)';
 }
 if (countdownEl) {
 countdownEl.style.display = 'none';
 }
 updateDb40StartBit();
 addSerialLog('Override expired - PLC Start check active again', 'info');
 }

 function updateOverrideCountdownDisplay() {
 const indicator = document.getElementById('db40StartIndicator');
 const statusText = document.getElementById('db40StartText');
 const countdownEl = document.getElementById('overrideCountdownText');
 if (visionOverrideSecondsLeft <= 0) {
 return;
 }
 if (indicator) {
 indicator.classList.add('connected');
 }
 if (countdownEl) {
 countdownEl.style.display = 'block';
 countdownEl.textContent = 'Active for ' + visionOverrideSecondsLeft + 's';
 }
 if (statusText) {
 statusText.innerHTML = '<span style="color: var(--accent-green);"> OVERRIDE ACTIVE</span><br><span style="font-size: 10px; color: var(--text-muted);">' + visionOverrideSecondsLeft + 's remaining</span>';
 }
 }

 function setVisionOverride() {
 if (visionOverrideActive) {
 return;
 }
 visionOverrideActive = true;
 visionOverrideSecondsLeft = OVERRIDE_DURATION_SECONDS;

 if (visionOverrideTimeoutId) {
 clearTimeout(visionOverrideTimeoutId);
 }
 if (visionOverrideCountdownIntervalId) {
 clearInterval(visionOverrideCountdownIntervalId);
 }

 const btn = document.getElementById('overrideStartBtn');
 if (btn) {
 btn.disabled = true;
 }
 updateOverrideCountdownDisplay();

 visionOverrideCountdownIntervalId = setInterval(function() {
 visionOverrideSecondsLeft = visionOverrideSecondsLeft - 1;
 if (visionOverrideSecondsLeft <= 0) {
 clearVisionOverride();
 return;
 }
 updateOverrideCountdownDisplay();
 }, 1000);

 visionOverrideTimeoutId = setTimeout(function() {
 clearVisionOverride();
 }, OVERRIDE_DURATION_SECONDS * 1000);

 addSerialLog('Override Start active for 1 minute - bypassing DB123.DBX40.0', 'info');
 }

 // Update YOLO parameters from sliders
 function updateYoloParams() {
 const confSlider = document.getElementById('yoloConfSlider');
 const iouSlider = document.getElementById('yoloIouSlider');
 const cropTopSlider = document.getElementById('yoloCropTopSlider');
 const cropBottomSlider = document.getElementById('yoloCropBottomSlider');
 
 if (confSlider) {
 objectParams.conf = parseFloat(confSlider.value);
 document.getElementById('yoloConfValue').textContent = objectParams.conf.toFixed(2);
 }
 if (iouSlider) {
 objectParams.iou = parseFloat(iouSlider.value);
 document.getElementById('yoloIouValue').textContent = objectParams.iou.toFixed(2);
 }
 if (cropTopSlider) {
 objectParams.crop_top_percent = parseInt(cropTopSlider.value);
 document.getElementById('yoloCropTopValue').textContent = objectParams.crop_top_percent;
 }
 if (cropBottomSlider) {
 objectParams.crop_bottom_percent = parseInt(cropBottomSlider.value);
 document.getElementById('yoloCropBottomValue').textContent = objectParams.crop_bottom_percent;
 }
 
 addSerialLog('YOLO params updated: conf=' + objectParams.conf + ', iou=' + objectParams.iou + ', crop_top=' + objectParams.crop_top_percent + '%, crop_bottom=' + objectParams.crop_bottom_percent + '%', 'info');
 }
 
 // Update simple detection parameters from sliders
 function updateSimpleParams() {
 const minAreaSlider = document.getElementById('minAreaSlider');
 const maxAreaSlider = document.getElementById('maxAreaSlider');
 const cannyLowSlider = document.getElementById('cannyLowSlider');
 const cannyHighSlider = document.getElementById('cannyHighSlider');
 const gaussianBlurSlider = document.getElementById('gaussianBlurSlider');
 const houghThresholdSlider = document.getElementById('houghThresholdSlider');
 
 if (minAreaSlider) {
 detectionParams.min_area = parseInt(minAreaSlider.value);
 detectionParams.contour_min_area = detectionParams.min_area;
 detectionParams.blob_min_area = detectionParams.min_area;
 document.getElementById('minAreaValue').textContent = detectionParams.min_area;
 }
 if (maxAreaSlider) {
 detectionParams.max_area = parseInt(maxAreaSlider.value);
 detectionParams.contour_max_area = detectionParams.max_area;
 detectionParams.blob_max_area = detectionParams.max_area;
 document.getElementById('maxAreaValue').textContent = detectionParams.max_area;
 }
 if (cannyLowSlider) {
 detectionParams.canny_low = parseInt(cannyLowSlider.value);
 detectionParams.edge_canny_low = detectionParams.canny_low;
 document.getElementById('cannyLowValue').textContent = detectionParams.canny_low;
 }
 if (cannyHighSlider) {
 detectionParams.canny_high = parseInt(cannyHighSlider.value);
 detectionParams.edge_canny_high = detectionParams.canny_high;
 document.getElementById('cannyHighValue').textContent = detectionParams.canny_high;
 }
 if (gaussianBlurSlider) {
 detectionParams.gaussian_blur = parseInt(gaussianBlurSlider.value);
 document.getElementById('gaussianBlurValue').textContent = detectionParams.gaussian_blur;
 }
 if (houghThresholdSlider) {
 detectionParams.hough_threshold = parseInt(houghThresholdSlider.value);
 document.getElementById('houghThresholdValue').textContent = detectionParams.hough_threshold;
 }
 
 addSerialLog('Detection params updated: min_area=' + detectionParams.min_area + ', max_area=' + detectionParams.max_area + ', canny=' + detectionParams.canny_low + '-' + detectionParams.canny_high, 'info');
 }
 
 // Reset simple parameters to defaults
 function resetSimpleParams() {
 detectionParams.min_area = 500;
 detectionParams.max_area = 50000;
 detectionParams.canny_low = 80;
 detectionParams.canny_high = 200;
 detectionParams.gaussian_blur = 7;
 detectionParams.hough_threshold = 80;
 detectionParams.contour_min_area = 500;
 detectionParams.contour_max_area = 50000;
 detectionParams.blob_min_area = 500;
 detectionParams.blob_max_area = 20000;
 detectionParams.edge_canny_low = 80;
 detectionParams.edge_canny_high = 200;
 
 document.getElementById('minAreaSlider').value = 500;
 document.getElementById('maxAreaSlider').value = 50000;
 document.getElementById('cannyLowSlider').value = 80;
 document.getElementById('cannyHighSlider').value = 200;
 document.getElementById('gaussianBlurSlider').value = 7;
 document.getElementById('houghThresholdSlider').value = 80;
 
 document.getElementById('minAreaValue').textContent = '500';
 document.getElementById('maxAreaValue').textContent = '50000';
 document.getElementById('cannyLowValue').textContent = '80';
 document.getElementById('cannyHighValue').textContent = '200';
 document.getElementById('gaussianBlurValue').textContent = '7';
 document.getElementById('houghThresholdValue').textContent = '80';
 
 addSerialLog('Detection params reset to defaults', 'info');
 }

 // Detection Method Switching
 function changeDetectionMethod() {
 const selector = document.getElementById('detectionMethodSelector');
 const infoDiv = document.getElementById('detectionMethodInfo');
 const methodDisplay = document.getElementById('currentMethodDisplay');
 const activeMethodDisplay = document.getElementById('activeMethodDisplay');
 const activeMethodSubtext = document.getElementById('activeMethodSubtext');
 const hiddenInput = document.getElementById('objectDetectionMethod');
 const yoloParamsDiv = document.getElementById('yoloParams');
 const simpleParamsDiv = document.getElementById('simpleParams');
 
 const selectedMethod = selector.value;
 
 // Update hidden input that the backend uses
 if (hiddenInput) {
 hiddenInput.value = selectedMethod;
 }
 
 // Show/hide parameter sections based on method
 if (yoloParamsDiv && simpleParamsDiv) {
 if (selectedMethod === 'yolo') {
 yoloParamsDiv.style.display = 'block';
 simpleParamsDiv.style.display = 'none';
 } else {
 yoloParamsDiv.style.display = 'none';
 simpleParamsDiv.style.display = 'block';
 }
 }
 
 // Update method display in stats (small version)
 if (methodDisplay) {
 const methodNames = {
 'yolo': 'YOLO AI',
 'contour': 'CONTOUR',
 'circle': 'CIRCLE',
 'blob': 'BLOB'
 };
 methodDisplay.textContent = methodNames[selectedMethod] || selectedMethod.toUpperCase();
 }
 
 // Update BIG active method display
 const methodDisplayNames = {
 'yolo': 'YOLO AI Model',
 'contour': 'Contour Detection',
 'circle': 'Circle Detection',
 'blob': 'Blob Detection'
 };
 
 const methodSubtexts = {
 'yolo': 'Neural network trained on your counters',
 'contour': 'Edge-based shape detection',
 'circle': 'Hough transform for circular objects',
 'blob': 'Region-based detection'
 };
 
 if (activeMethodDisplay) {
 activeMethodDisplay.textContent = methodDisplayNames[selectedMethod] || selectedMethod.toUpperCase();
 }
 
 if (activeMethodSubtext) {
 activeMethodSubtext.textContent = methodSubtexts[selectedMethod] || '';
 }
 
 // Update info text
 const methodInfo = {
 'yolo': '<strong style="color: #ce93d8;">YOLO AI Model:</strong> Uses trained neural network. Best accuracy, requires model file. Adjust confidence and IOU below.',
 'contour': '<strong style="color: #64b5f6;">Contour Detection:</strong> Finds shapes by detecting edges and outlines. Fast, no AI needed. Good for clear backgrounds. Adjust edge detection sensitivity below.',
 'circle': '<strong style="color: #64b5f6;">Circle Detection (Hough):</strong> Specialized algorithm for finding circular shapes. Fast, works well for round counters. Adjust threshold and area limits below.',
 'blob': '<strong style="color: #64b5f6;">Blob Detection:</strong> Finds connected regions of similar color/brightness. Very fast, simple. Good for high-contrast objects. Adjust area limits below.'
 };
 
 if (infoDiv) {
 infoDiv.innerHTML = methodInfo[selectedMethod] || 'Unknown method';
 }
 
 // Log the change
 addSerialLog('Detection method changed to: ' + selectedMethod.toUpperCase(), 'info');
 
 // If detection is running, notify user it will use new method on next cycle
 if (objectDetectionActive) {
 addSerialLog('New method will be used starting next detection cycle (1 second)', 'info');
 }
 }

 // DB40.0 Start Bit Status Functions
 async function updateDb40StartBit() {
 if (visionOverrideActive) {
 updateOverrideCountdownDisplay();
 return;
 }

 const indicator = document.getElementById('db40StartIndicator');
 const statusText = document.getElementById('db40StartText');

 if (!indicator || !statusText) {
 console.error('[DB40 Start] Elements not found!');
 return;
 }

 try {
 // Get DB40.0 start bit
 const response = await fetch(`${API_BASE}/api/plc/db40/start`, {
 signal: AbortSignal.timeout(5000)
 });

 if (!response.ok) {
 throw new Error(`HTTP ${response.status}`);
 }

 const data = await response.json();

 if (!data.success) {
 throw new Error(data.error || 'Failed to read start bit');
 }

 const startBit = data.start || false;

 if (startBit) {
 indicator.classList.add('connected');
 updateStatusText(statusText, `<span style="color: var(--accent-green);"> ACTIVE (TRUE)</span><br><span style="font-size: 10px; color: var(--text-muted);">Vision processing enabled</span>`);
 } else {
 indicator.classList.remove('connected');
 updateStatusText(statusText, `<span style="color: var(--md-sys-color-primary);"> INACTIVE (FALSE)</span><br><span style="font-size: 10px; color: var(--text-muted);">Awaiting PLC start command</span>`);
 }
 } catch (error) {
 console.error('[DB40 Start] Error:', error);
 indicator.classList.remove('connected');
 let errorMsg = error.message || 'Unknown error';
 if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
 errorMsg = 'Backend not responding';
 }
 updateStatusText(statusText, `<span style="color: var(--accent-red);"> Error</span><br><span style="font-size: 10px; color: var(--text-muted);">${errorMsg}</span>`);
 }
 }

 // PLC Start Status Banner Functions (legacy - redirects to new functions for compatibility)
 async function updatePlcStartStatusBanner() {
 // Old banner has been replaced with dual-status display
 // This function now just calls the new status functions
 await updatePlcConnectionStatus();
 await updateDb40StartBit();
 }
 </script>

 <script>
   // Animated Factory Sidebar Background
   function initSidebarAnimation() {
     const container = document.getElementById('sidebarAnimatedBg');
     if (!container) return;

     for (let i = 0; i < 15; i++) {
       const particle = document.createElement('div');
       particle.className = 'factory-particle';
       particle.style.width = Math.random() * 4 + 2 + 'px';
       particle.style.height = particle.style.width;
       particle.style.left = Math.random() * 100 + '%';
       particle.style.animationDuration = Math.random() * 10 + 8 + 's';
       particle.style.animationDelay = Math.random() * 5 + 's';
       container.appendChild(particle);
     }

     for (let i = 0; i < 8; i++) {
       const line = document.createElement('div');
       line.className = 'circuit-line';
       line.style.top = Math.random() * 100 + '%';
       line.style.width = Math.random() * 150 + 100 + 'px';
       line.style.animationDuration = Math.random() * 6 + 4 + 's';
       line.style.animationDelay = Math.random() * 3 + 's';
       container.appendChild(line);
     }
   }

   if (document.readyState === 'loading') {
     document.addEventListener('DOMContentLoaded', initSidebarAnimation);
   } else {
     initSidebarAnimation();
   }
 </script>
</body>
</html>

