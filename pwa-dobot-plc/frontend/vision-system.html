<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0f051a">
    <meta name="description" content="Vision System Control">
    <title>Vision System - Smart Factory</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Fira+Code:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ========== CSS VARIABLES - NEXUS FLOW ========== */
        :root {
            --primary-cyan: #00ffff;
            --primary-pink: #ff00ff;
            --primary-purple: #7c3aed;
            --primary-orange: #f97316;
            --dark-bg: #1a0b2e;
            --darker-bg: #0f051a;
            --card-bg: rgba(26, 11, 46, 0.85);
            --bg-panel: rgba(15, 5, 26, 0.9);
            --border-color: rgba(0, 255, 255, 0.3);
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-orange: #f59e0b;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
        }

        /* ========== RESET & BASE ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-mono);
            background: var(--darker-bg);
            min-height: 100vh;
            color: var(--text-primary);
            display: flex;
            overflow-x: hidden;
            position: relative;
            line-height: 1.6;
        }

        /* ========== CYBERPUNK BACKGROUND ========== */
        .cyber-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--darker-bg);
            overflow: hidden;
            z-index: -5;
        }

        .cyber-gradient {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(124, 58, 237, 0.15) 0%, transparent 50%);
            animation: gradientRotate 30s linear infinite;
            filter: blur(40px);
        }

        @keyframes gradientRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
        }

        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        .orb {
            position: fixed;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.5;
            animation: orbFloat 20s ease-in-out infinite;
            pointer-events: none;
            z-index: -4;
        }

        .orb1 {
            width: 300px;
            height: 300px;
            background: var(--primary-pink);
            top: 10%;
            left: -150px;
        }

        .orb2 {
            width: 400px;
            height: 400px;
            background: var(--primary-cyan);
            bottom: 10%;
            right: -200px;
            animation-delay: 5s;
        }

        @keyframes orbFloat {
            0%, 100% { transform: translate(0, 0) scale(1); }
            33% { transform: translate(100px, -50px) scale(1.1); }
            66% { transform: translate(-50px, 100px) scale(0.9); }
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .scanlines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(transparent 0%, rgba(0, 255, 255, 0.03) 50%, transparent 100%);
            background-size: 100% 4px;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        /* ========== SIDEBAR ========== */
        .sidebar {
            width: 280px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-color);
            padding: 24px;
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
        }

        .sidebar-header {
            margin-bottom: 40px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-header h2 {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary-cyan);
            text-shadow: 0 0 20px var(--primary-cyan);
            margin-bottom: 8px;
        }

        .sidebar-header h2::before {
            content: '>';
            margin-right: 0.5rem;
            color: var(--primary-orange);
        }

        .sidebar-header h2::after {
            content: '_';
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .sidebar-header p {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .sidebar-menu {
            list-style: none;
        }

        .sidebar-menu-item {
            margin-bottom: 8px;
        }

        .sidebar-menu-link {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 18px;
            text-decoration: none;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 1px;
            border: 1px solid transparent;
            clip-path: polygon(10px 0%, 100% 0%, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0% 100%, 0% 10px);
        }

        .sidebar-menu-link:hover {
            color: var(--primary-cyan);
            border-color: var(--border-color);
            background: rgba(0, 255, 255, 0.05);
            text-shadow: 0 0 10px var(--primary-cyan);
        }

        .sidebar-menu-link.active {
            background: rgba(255, 0, 255, 0.1);
            color: var(--primary-pink);
            border-color: var(--primary-pink);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
        }

        .sidebar-menu-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        /* ========== MAIN CONTENT ========== */
        .main-content {
            flex: 1;
            margin-left: 280px;
            padding: 24px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* ========== HEADER ========== */
        .header {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            padding: 24px 32px;
            margin-bottom: 24px;
            clip-path: polygon(20px 0%, 100% 0%, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0% 100%, 0% 20px);
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: 3px;
            text-transform: uppercase;
            background: linear-gradient(135deg, var(--primary-pink), var(--primary-cyan));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
        }

        /* ========== CONTENT ========== */
        .content {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            padding: 30px;
            clip-path: polygon(20px 0%, 100% 0%, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0% 100%, 0% 20px);
        }

        .camera-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        @media (max-width: 1024px) {
            .camera-section {
                grid-template-columns: 1fr;
            }
        }

        .camera-viewer {
            background: var(--bg-panel);
            padding: 24px;
            border: 1px solid var(--border-color);
            clip-path: polygon(15px 0%, 100% 0%, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0% 100%, 0% 15px);
        }

        .camera-viewer h3 {
            color: var(--primary-cyan);
            margin-bottom: 16px;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .camera-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            background: var(--accent-red);
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px var(--accent-red);
        }

        .status-indicator.connected {
            background: var(--accent-green);
            box-shadow: 0 0 10px var(--accent-green);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .camera-frame {
            width: 100%;
            max-width: 100%;
            height: auto;
            background: #000;
            border: 1px solid var(--border-color);
            min-height: 300px;
            object-fit: contain;
        }

        .camera-controls {
            display: flex;
            gap: 10px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        /* ========== BUTTONS ========== */
        .btn {
            padding: 12px 20px;
            border: 1px solid transparent;
            font-family: var(--font-mono);
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            clip-path: polygon(8px 0%, 100% 0%, calc(100% - 8px) 100%, 0% 100%);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-purple), var(--primary-cyan));
            color: white;
            border-color: var(--primary-cyan);
        }

        .btn-primary:hover {
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--accent-red), #dc2626);
            color: white;
            border-color: var(--accent-red);
        }

        .btn-danger:hover {
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
            transform: translateY(-2px);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--accent-green), #059669);
            color: white;
            border-color: var(--accent-green);
        }

        .btn-success:hover {
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* ========== PANELS ========== */
        .panel {
            padding: 18px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            margin-top: 20px;
            clip-path: polygon(10px 0%, 100% 0%, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0% 100%, 0% 10px);
        }

        .panel h4 {
            color: var(--primary-cyan);
            font-size: 12px;
            margin-bottom: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .info-panel {
            background: var(--bg-panel);
            padding: 24px;
            margin-top: 24px;
            border: 1px solid var(--border-color);
            clip-path: polygon(15px 0%, 100% 0%, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0% 100%, 0% 15px);
        }

        .info-panel h3 {
            color: var(--primary-cyan);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            font-size: 13px;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* ========== SERIAL LOG ========== */
        #serialLog {
            background: rgba(5, 2, 10, 0.95) !important;
            border: 1px solid var(--border-color);
            padding: 16px;
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--accent-green);
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.7;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* ========== RANGE SLIDERS ========== */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(0, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--primary-cyan), var(--primary-pink));
            cursor: pointer;
            transition: all 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        /* ========== SCROLLBAR ========== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--darker-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(var(--primary-cyan), var(--primary-pink));
            border-radius: 4px;
        }

        /* ========== RESPONSIVE ========== */
        @media (max-width: 768px) {
            .sidebar {
                width: 80px;
                padding: 15px 10px;
            }

            .sidebar-header h2,
            .sidebar-header p,
            .sidebar-menu-link span:not(.sidebar-menu-icon) {
                display: none;
            }

            .main-content {
                margin-left: 80px;
                padding: 16px;
            }

            .sidebar-menu-link {
                justify-content: center;
                padding: 14px;
            }

            .scanlines::before {
                display: none;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .cyber-gradient, .grid-lines, .orb, .scanlines::before {
                animation: none !important;
            }
        }
    </style>
</head>
<body>
    <!-- Cyberpunk Background Layers -->
    <div class="cyber-bg">
        <div class="cyber-gradient"></div>
    </div>
    <div class="grid-overlay">
        <div class="grid-lines"></div>
    </div>
    <div class="orb orb1"></div>
    <div class="orb orb2"></div>
    <div class="scanlines"></div>

    <!-- Sidebar Navigation -->
    <nav class="sidebar">
        <div class="sidebar-header">
            <h2>Smart Factory</h2>
            <p>Control System</p>
        </div>
        <ul class="sidebar-menu">
            <li class="sidebar-menu-item">
                <a href="/" class="sidebar-menu-link">
                    <span class="sidebar-menu-icon">&#127968;</span>
                    <span>Home</span>
                </a>
            </li>
            <li class="sidebar-menu-item">
                <a href="/robot-arm.html" class="sidebar-menu-link">
                    <span class="sidebar-menu-icon">&#129302;</span>
                    <span>Robot Arm</span>
                </a>
            </li>
            <li class="sidebar-menu-item">
                <a href="/smart-factory.html" class="sidebar-menu-link">
                    <span class="sidebar-menu-icon">&#127981;</span>
                    <span>Smart Factory</span>
                </a>
            </li>
            <li class="sidebar-menu-item">
                <a href="/vision-system.html" class="sidebar-menu-link active">
                    <span class="sidebar-menu-icon">&#128065;</span>
                    <span>Vision System</span>
                </a>
            </li>
            <li class="sidebar-menu-item">
                <a href="/rfid.html" class="sidebar-menu-link">
                    <span class="sidebar-menu-icon">&#128225;</span>
                    <span>RFID</span>
                </a>
            </li>
        </ul>
    </nav>

    <!-- Main Content -->
    <div class="main-content">
        <div class="container">
            <div class="header">
                <div class="header-content">
                    <h1>&#128065; Vision System</h1>
                </div>
            </div>

            <!-- PLC Start Command Status Banner -->
            <div id="plcStartStatusBanner" class="content" style="margin-bottom: 24px; padding: 16px 24px;">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <span class="status-indicator" id="plcStartIndicator"></span>
                    <span id="plcStartStatusText" style="color: var(--text-secondary); font-size: 13px; font-weight: 600;">
                        Loading PLC status...
                    </span>
                </div>
            </div>

            <!-- Top-Level Detection Settings -->
            <div class="content">
                <div class="camera-section">
                    <!-- Camera Viewer -->
                    <div class="camera-viewer">
                        <h3>&#128247; Camera Feed</h3>
                        <div class="camera-status">
                            <span class="status-indicator" id="cameraStatusIndicator"></span>
                            <span id="cameraStatusText">Disconnected</span>
                        </div>
                        <img id="cameraFrame" class="camera-frame" src="" alt="Camera Feed" style="display: none;">
                        <div id="cameraPlaceholder" style="min-height: 300px; display: flex; align-items: center; justify-content: center; color: var(--text-muted); flex-direction: column; gap: 10px; background: rgba(10, 0, 20, 0.8); border: 1px solid var(--border-color);">
                            <div style="font-size: 48px;">&#128247;</div>
                            <div>Camera not connected</div>
                        </div>
                        <div class="camera-controls">
                            <button class="btn btn-primary" id="connectCameraBtn" onclick="connectCamera()">
                                <span>&#128224;</span>
                                <span>Connect</span>
                            </button>
                            <button class="btn btn-danger" id="disconnectCameraBtn" onclick="disconnectCamera()" disabled>
                                <span>&#128308;</span>
                                <span>Disconnect</span>
                            </button>
                            <button class="btn btn-success" id="captureBtn" onclick="captureFrame()" disabled>
                                <span>&#128248;</span>
                                <span>Capture</span>
                            </button>
                            <button class="btn btn-primary" id="fullscreenBtn" onclick="toggleFullscreen()" disabled>
                                <span>&#9974;</span>
                                <span>Fullscreen</span>
                            </button>
                            <button class="btn btn-primary" id="settingsBtn" onclick="openCameraSettings()" disabled>
                                <span>&#9881;&#65039;</span>
                                <span>Settings</span>
                            </button>
                        </div>
                        
                        <!-- Image Adjustment Controls -->
                        <div id="imageAdjustments" class="panel" style="display: none;">
                            <h4>Image Adjustments</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                <div>
                                    <label style="display: block; color: var(--text-secondary); font-size: 11px; margin-bottom: 6px;">Brightness</label>
                                    <input type="range" id="brightnessSlider" min="-100" max="100" value="0" style="width: 100%;" oninput="updateImageAdjustments()">
                                    <span id="brightnessValue" style="color: var(--text-muted); font-size: 10px;">0</span>
                                </div>
                                <div>
                                    <label style="display: block; color: var(--text-secondary); font-size: 11px; margin-bottom: 6px;">Contrast</label>
                                    <input type="range" id="contrastSlider" min="-100" max="100" value="0" style="width: 100%;" oninput="updateImageAdjustments()">
                                    <span id="contrastValue" style="color: var(--text-muted); font-size: 10px;">0</span>
                                </div>
                            </div>
                            <button class="btn btn-primary" onclick="resetImageAdjustments()" style="margin-top: 12px; width: 100%; font-size: 11px; padding: 8px;">
                                Reset Adjustments
                            </button>
                        </div>
                        
                        <!-- Camera Crop/Zoom Controls -->
                        <div style="margin-top: 20px; padding: 16px; background: rgba(10, 0, 20, 0.6); border: 1px solid var(--border-color); border-radius: 8px;">
                            <h5 style="color: var(--primary-cyan); font-size: 12px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px;">
                                üîç Camera Crop/Zoom
                            </h5>
                            <div style="margin-bottom: 12px;">
                                <label style="display: flex; align-items: center; gap: 8px; color: var(--text-secondary); font-size: 11px; cursor: pointer;">
                                    <input type="checkbox" id="cropEnabled" onchange="toggleCrop()" style="cursor: pointer;">
                                    <span>Enable Crop/Zoom</span>
                                </label>
                            </div>
                            <div id="cropControls" style="display: none; grid-template-columns: 1fr 1fr; gap: 12px;">
                                <div>
                                    <label style="display: block; color: var(--text-secondary); font-size: 10px; margin-bottom: 4px;">X Position (%)</label>
                                    <input type="range" id="cropX" min="0" max="100" value="0" step="1" oninput="updateCropPreview()" style="width: 100%;">
                                    <div style="text-align: center; font-size: 10px; color: var(--primary-cyan); margin-top: 4px;" id="cropXValue">0%</div>
                                </div>
                                <div>
                                    <label style="display: block; color: var(--text-secondary); font-size: 10px; margin-bottom: 4px;">Y Position (%)</label>
                                    <input type="range" id="cropY" min="0" max="100" value="0" step="1" oninput="updateCropPreview()" style="width: 100%;">
                                    <div style="text-align: center; font-size: 10px; color: var(--primary-cyan); margin-top: 4px;" id="cropYValue">0%</div>
                                </div>
                                <div>
                                    <label style="display: block; color: var(--text-secondary); font-size: 10px; margin-bottom: 4px;">Width (%)</label>
                                    <input type="range" id="cropWidth" min="1" max="100" value="100" step="1" oninput="updateCropPreview()" style="width: 100%;">
                                    <div style="text-align: center; font-size: 10px; color: var(--primary-cyan); margin-top: 4px;" id="cropWidthValue">100%</div>
                                </div>
                                <div>
                                    <label style="display: block; color: var(--text-secondary); font-size: 10px; margin-bottom: 4px;">Height (%)</label>
                                    <input type="range" id="cropHeight" min="1" max="100" value="100" step="1" oninput="updateCropPreview()" style="width: 100%;">
                                    <div style="text-align: center; font-size: 10px; color: var(--primary-cyan); margin-top: 4px;" id="cropHeightValue">100%</div>
                                </div>
                            </div>
                            <div style="margin-top: 12px;">
                                <button class="btn btn-primary" onclick="saveCropSettings()" style="font-size: 10px; padding: 6px 12px; width: 100%;">
                                    üíæ Save Crop Settings
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Analyzed Image Viewer -->
                    <div class="camera-viewer">
                        <h3>&#128269; Analyzed Image</h3>
                        <div class="camera-status">
                            <span class="status-indicator" id="analyzedStatusIndicator"></span>
                            <span id="analyzedStatusText">No analysis yet</span>
                        </div>
                        <img id="analyzedImage" class="camera-frame" src="" alt="Analyzed Image" style="display: none;">
                        <div id="analyzedPlaceholder" style="min-height: 300px; display: flex; align-items: center; justify-content: center; color: var(--text-muted); flex-direction: column; gap: 10px; background: rgba(10, 0, 20, 0.8); border: 1px solid var(--border-color);">
                            <div style="font-size: 48px;">&#128269;</div>
                            <div>Analysis results will appear here</div>
                        </div>
                    </div>
                </div>

                <!-- Detection Results Section -->
                <div style="margin-top: 24px;">
                    <!-- Detection Stats Display -->
                    <div id="objectDetectionStats" class="panel" style="display: block;">
                        <h4>Detection Results</h4>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 12px; align-items: center;">
                            <span style="color: var(--text-secondary); font-size: 13px; font-weight: 600;">Objects Detected:</span>
                            <span id="currentObjectCount" style="color: var(--accent-green); font-weight: 700; font-size: 20px;">0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--border-color);">
                            <span style="color: var(--text-secondary); font-size: 10px;">Last Updated:</span>
                            <span id="lastDetectionTime" style="color: var(--text-muted); font-size: 10px;">Never</span>
                        </div>
                    </div>
                    
                    <!-- Counter Timeline -->
                    <div id="counterTimeline" class="panel" style="display: block;">
                        <h4>Counter Detection Timeline</h4>
                        <div id="counterTimelineList" style="max-height: 200px; overflow-y: auto;">
                            <div style="color: var(--text-muted); text-align: center; padding: 12px; font-size: 11px;">No counters detected yet</div>
                        </div>
                    </div>
                    
                    <!-- Saved Counter Images Gallery -->
                    <div id="counterImagesGallery" class="panel" style="display: block;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;">
                            <h4 style="margin: 0;">Saved Counter Images</h4>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-danger" onclick="deleteAllCounterImages()" style="font-size: 10px; padding: 6px 10px;">
                                    &#128465; Delete All
                                </button>
                                <button class="btn btn-primary" onclick="refreshCounterImages()" style="font-size: 10px; padding: 6px 10px;">
                                    &#128260; Refresh
                                </button>
                            </div>
                        </div>
                        <div id="counterImagesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px; max-height: 400px; overflow-y: auto;">
                            <div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">Loading images...</div>
                        </div>
                        <div id="counterImagesStatus" style="margin-top: 8px; color: var(--text-muted); font-size: 10px;"></div>
                    </div>
                    
                    <!-- Defect Detection Section -->
                    <div id="defectDetectionSection" class="panel" style="display: block;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;">
                            <h4 style="margin: 0;">Defect Detection</h4>
                            <button class="btn btn-success" onclick="analyzeAllCountersForDefects()" style="font-size: 10px; padding: 6px 10px;">
                                &#128269; Analyze All
                            </button>
                        </div>
                        <div style="color: var(--text-secondary); font-size: 11px; margin-bottom: 12px;">
                            Analyzes saved counter images to detect color changes on the counter surface
                        </div>
                        <div id="defectResultsList" style="max-height: 300px; overflow-y: auto;">
                            <div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No defect analysis performed yet. Click "Analyze All" to check all counters.</div>
                        </div>
                    </div>

                    <!-- PLC DB123 Configuration Section -->
                    <div id="plcDb123ConfigSection" class="panel" style="display: block;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;">
                            <h4 style="margin: 0;">PLC DB123 Communication Settings</h4>
                            <button class="btn btn-primary" onclick="saveDb123Config()" style="font-size: 10px; padding: 6px 10px;">
                                &#128190; Save Settings
                            </button>
                        </div>
                        <div style="color: var(--text-secondary); font-size: 11px; margin-bottom: 16px;">
                            Configure how vision detection results are written to Siemens PLC DB123 tags
                        </div>
                        
                        <div style="margin-bottom: 16px;">
                            <label style="display: flex; align-items: center; gap: 10px; color: var(--text-secondary); font-size: 12px; cursor: pointer;">
                                <input type="checkbox" id="db123Enabled" style="width: 16px; height: 16px; cursor: pointer; accent-color: var(--primary-cyan);">
                                <span>Enable DB123 Communication</span>
                            </label>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px;">
                            <div>
                                <label style="display: block; color: var(--text-secondary); font-size: 11px; margin-bottom: 6px;">DB Number</label>
                                <input type="number" id="db123Number" value="123" min="1" max="65535" style="width: 100%; padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); color: var(--text-primary); font-family: var(--font-mono); font-size: 12px;">
                            </div>
                        </div>

                        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color);">
                            <h5 style="color: var(--primary-cyan); font-size: 11px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px;">Tag Addresses (Read-Only Reference)</h5>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px; color: var(--text-secondary);">
                                <div>Start: DB123.DBX40.0</div>
                                <div>Connected: DB123.DBX40.1</div>
                                <div>Busy: DB123.DBX40.2</div>
                                <div>Completed: DB123.DBX40.3</div>
                                <div>Object_Detected: DB123.DBX40.4</div>
                                <div>Object_OK: DB123.DBX40.5</div>
                                <div>Defect_Detected: DB123.DBX40.6</div>
                                <div>Object_Number: DB123.DBW42</div>
                                <div>Defect_Number: DB123.DBW44</div>
                            </div>
                        </div>

                        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <h5 style="color: var(--primary-cyan); font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin: 0;">Current Tag Status</h5>
                                <button class="btn btn-primary" onclick="refreshPlcTags()" style="font-size: 9px; padding: 4px 8px;">
                                    &#128260; Refresh
                                </button>
                            </div>
                            <div id="plcTagsStatus" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 10px;">
                                <div style="color: var(--text-muted); text-align: center; padding: 12px; grid-column: 1 / -1;">Loading tag status...</div>
                            </div>
                        </div>

                        <div style="margin-top: 16px; padding: 12px; background: rgba(0, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: 4px;">
                            <div style="color: var(--primary-cyan); font-size: 10px; font-weight: 700; margin-bottom: 6px;">Status:</div>
                            <div id="db123Status" style="color: var(--text-secondary); font-size: 10px;">Loading...</div>
                            <div style="margin-top: 12px;">
                                <button class="btn btn-primary" onclick="connectToPLC()" style="font-size: 10px; padding: 6px 12px; width: 100%;">
                                    üîå Connect to PLC
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Hidden inputs for method -->
                    <input type="hidden" id="objectDetectionMethod" value="yolo">
                    <input type="hidden" id="continuousObjectDetection" value="true">
                </div>

                <!-- Serial Monitor Log -->
                <div class="panel" style="margin-top: 24px;">
                    <h4 style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;" onclick="toggleSerialMonitor()">
                        <span>
                            <span id="serialMonitorToggleIcon">&#9654;</span> Serial Monitor Log
                        </span>
                        <button class="btn btn-primary" onclick="clearSerialLog(event)" style="font-size: 10px; padding: 6px 10px; margin: 0;">
                            Clear Log
                        </button>
                    </h4>
                    <div id="serialMonitor" style="display: none;">
                        <div id="serialLog">
                            <div style="color: var(--text-muted);">Vision System Serial Monitor - Ready</div>
                            <div style="color: var(--text-muted);">Waiting for camera events...</div>
                        </div>
                        <div style="margin-top: 10px; display: flex; gap: 12px;">
                            <label style="display: flex; align-items: center; gap: 8px; color: var(--text-secondary); font-size: 11px; cursor: pointer;">
                                <input type="checkbox" id="autoScrollLog" checked style="width: 14px; height: 14px; cursor: pointer; accent-color: var(--primary-cyan);">
                                <span>Auto-scroll</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; color: var(--text-secondary); font-size: 11px; cursor: pointer;">
                                <input type="checkbox" id="timestampLog" checked style="width: 14px; height: 14px; cursor: pointer; accent-color: var(--primary-cyan);">
                                <span>Show timestamps</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Information Panel -->
                <div class="info-panel">
                    <h3 onclick="toggleInfoPanel()">
                        <span id="infoToggleIcon">&#9654;</span>
                        <span>How the Vision System Works</span>
                    </h3>
                    <div id="infoContent" style="display: none;">
                        <div style="color: var(--text-secondary); line-height: 1.8; font-size: 13px;">
                            <p style="margin-bottom: 16px;">
                                Every second the camera grabs a snapshot, the YOLO microservice finds circular counters,
                                the backend saves any new counters with a tight crop, and defect detection runs instantly.
                                The timeline, saved image gallery, and defect list update themselves as soon as this happens.
                            </p>

                            <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">&#127909; Camera Snapshots</h4>
                            <ul style="margin-left: 24px; margin-bottom: 16px;">
                                <li>USB camera (index 0) captures a JPEG every second at 640√ó480</li>
                                <li>The raw snapshot feeds the analyzed image and the saved counter crops</li>
                                <li>The analyzed image you see is refreshed once per second (no stream required)</li>
                            </ul>

                            <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">&#128269; Counter Tracking Flow</h4>
                            <ol style="margin-left: 24px; margin-bottom: 16px;">
                                <li><strong>YOLO Detection:</strong> Snapshot goes to the vision microservice (15% confidence, 0.45 IOU)</li>
                                <li><strong>Position Matching:</strong> Each detection is compared with the last seen position so counters keep their number</li>
                                <li><strong>Saving:</strong> New numbers trigger a tight crop (5 px padding) stored in <code style="background: var(--darker-bg); padding: 2px 6px; color: var(--primary-cyan);">~/counter_images</code></li>
                                <li><strong>Auto Defect Detection:</strong> Each saved image is analyzed right away; results are stored for the defect list</li>
                                <li><strong>UI Update:</strong> Timeline, gallery, and defect panel pull the latest info every few seconds</li>
                            </ol>

                            <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">&#9881;&#65039; Automatic Defect Detection</h4>
                            <ul style="margin-left: 24px; margin-bottom: 16px;">
                                <li>When a counter image is saved, the backend isolates the circular surface and checks for color changes &gt; 110</li>
                                <li>The stored defect results feed the "Defect Detection" card without needing to press "Analyze All"</li>
                                <li>"Analyze All" simply re-runs checks if you want to double‚Äëcheck the latest images</li>
                            </ul>

                            <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">&#128465;&#65039; Resetting</h4>
                            <ul style="margin-left: 24px; margin-bottom: 16px;">
                                <li>The red "Delete All" button wipes saved images, defect data, and the detection timeline</li>
                                <li>After deleting, the next detections start again at Counter 1</li>
                            </ul>

                            <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">&#128161; Tips for Best Results</h4>
                            <ul style="margin-left: 24px; margin-bottom: 16px;">
                                <li>Keep lighting even so color-based defect checks stay accurate</li>
                                <li>Use a contrasting belt color (blue works best for white counters)</li>
                                <li>Keep counters fully in frame when you want them saved</li>
                                <li>If YOLO misses one, move it back into frame; the number will be reused automatically</li>
                            </ul>

                            <h4 style="color: var(--primary-pink); margin-top: 24px; margin-bottom: 12px;">&#128295; Technical Notes</h4>
                            <ul style="margin-left: 24px; margin-bottom: 16px;">
                                <li>Backend: Flask + OpenCV + YOLO microservice (Ultralytics) managed by PM2</li>
                                <li>Saved data lives in <code style="background: var(--darker-bg); padding: 2px 6px; color: var(--primary-cyan);">~/counter_images</code> (images + JSON logs)</li>
                                <li>All API routes are documented in <code style="background: var(--darker-bg); padding: 2px 6px; color: var(--primary-cyan);">app.py</code> if you need custom tooling</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = window.location.origin;
        let cameraConnected = false;
        let streamInterval = null;
        let autoAnalyzeInterval = null;
        let autoAnalyzeActive = false;
        let objectDetectionInterval = null;
        let objectDetectionActive = false;
        let fullAnalysisInterval = null;
        let fullAnalysisActive = false;
        let counterImagesFirstLoad = true;

        window.addEventListener('load', () => {
            // Set up image event handlers
            const cameraFrame = document.getElementById('cameraFrame');
            if (cameraFrame) {
                cameraFrame.addEventListener('error', function() {
                    handleStreamError(this);
                });
                cameraFrame.addEventListener('load', function() {
                    handleStreamLoad(this);
                });
            }
            
            startStreamImmediately();
            loadDetectionParams();
            loadDb123Config();
            updatePlcTagsStatus();
            updatePlcStartStatusBanner();
            loadCropSettings();
            topLevelObjectDetectionEnabled = true;
            objectDetectionEnabled = true;
            topLevelDefectDetectionEnabled = true;
            checkCameraStatus();
            setTimeout(() => {
                refreshCounterImages();
                updateCounterTimelineFromImages();
                setInterval(() => {
                    refreshCounterImages();
                    updateCounterTimelineFromImages();
                }, 15000);
            }, 1000);
            setTimeout(() => {
                addSerialLog('Vision System initialized', 'info');
                addSerialLog('Camera stream starting immediately', 'info');
                addSerialLog('Object detection enabled by default', 'info');
                addSerialLog('Background subtraction enabled for conveyor belt detection', 'info');
                addSerialLog('Auto-analysis will start automatically when camera connects', 'info');
                addSerialLog('Serial monitor ready', 'info');
            }, 500);
            setTimeout(() => {
                if (cameraConnected && !objectDetectionActive) {
                    const continuousCheckbox = document.getElementById('continuousObjectDetection');
                    if (continuousCheckbox) continuousCheckbox.checked = true;
                    startObjectDetection();
                }
            }, 2000);
        });

        async function checkCameraStatus() {
            try {
                const response = await fetch(`${API_BASE}/api/camera/status`);
                const data = await response.json();
                if (data.connected) {
                    updateCameraStatus(true);
                    startStream();
                    setTimeout(() => {
                        if (!objectDetectionActive) {
                            const continuousCheckbox = document.getElementById('continuousObjectDetection');
                            if (continuousCheckbox) continuousCheckbox.checked = true;
                            startObjectDetection();
                        }
                    }, 1000);
                } else {
                    updateCameraStatus(false);
                }
            } catch (error) {
                console.error('Error checking camera status:', error);
                updateCameraStatus(false);
            }
        }

        let detectionHistory = [];
        let currentResults = null;
        const counterFirstAppearance = {};

        function updateCameraStatus(connected) {
            cameraConnected = connected;
            const indicator = document.getElementById('cameraStatusIndicator');
            const statusText = document.getElementById('cameraStatusText');
            const connectBtn = document.getElementById('connectCameraBtn');
            const disconnectBtn = document.getElementById('disconnectCameraBtn');
            const captureBtn = document.getElementById('captureBtn');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const settingsBtn = document.getElementById('settingsBtn');
            const frame = document.getElementById('cameraFrame');
            const placeholder = document.getElementById('cameraPlaceholder');

            if (connected) {
                indicator.classList.add('connected');
                statusText.textContent = 'Connected';
                if (connectBtn) connectBtn.disabled = true;
                if (disconnectBtn) disconnectBtn.disabled = false;
                if (captureBtn) captureBtn.disabled = false;
                if (fullscreenBtn) fullscreenBtn.disabled = false;
                if (settingsBtn) settingsBtn.disabled = false;
                if (frame) frame.style.display = 'block';
                if (placeholder) placeholder.style.display = 'none';
                addSerialLog('Camera status: CONNECTED', 'camera');
            } else {
                indicator.classList.remove('connected');
                statusText.textContent = 'Disconnected';
                if (connectBtn) connectBtn.disabled = false;
                if (disconnectBtn) disconnectBtn.disabled = true;
                if (captureBtn) captureBtn.disabled = true;
                if (fullscreenBtn) fullscreenBtn.disabled = true;
                if (settingsBtn) settingsBtn.disabled = true;
                if (frame) frame.style.display = 'none';
                if (placeholder) placeholder.style.display = 'flex';
                stopStream();
                addSerialLog('Camera status: DISCONNECTED', 'camera');
            }
        }

        async function connectCamera() {
            try {
                const response = await fetch(`${API_BASE}/api/camera/connect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index: 0, width: 640, height: 480 })
                });
                const data = await response.json();
                if (data.success) {
                    updateCameraStatus(true);
                    startStream();
                    setTimeout(() => {
                        if (!objectDetectionActive) {
                            const continuousCheckbox = document.getElementById('continuousObjectDetection');
                            if (continuousCheckbox) continuousCheckbox.checked = true;
                            startObjectDetection();
                        }
                    }, 1500);
                } else {
                    alert('Failed to connect camera: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error connecting camera:', error);
                alert('Error connecting camera: ' + error.message);
            }
        }

        async function disconnectCamera() {
            try {
                addSerialLog('Disconnecting camera...', 'camera');
                await fetch(`${API_BASE}/api/camera/disconnect`, { method: 'POST' });
                updateCameraStatus(false);
                if (objectDetectionActive) stopObjectDetection();
                if (fullAnalysisActive) stopFullAnalysis();
                addSerialLog('Camera disconnected', 'info');
            } catch (error) {
                console.error('Error disconnecting camera:', error);
                addSerialLog(`Camera disconnect error: ${error.message}`, 'error');
            }
        }

        function startStream() {
            if (streamInterval) return;
            const frame = document.getElementById('cameraFrame');
            frame.style.display = 'block';
            const placeholder = document.getElementById('cameraPlaceholder');
            if (placeholder) placeholder.style.display = 'none';
            addSerialLog('Camera snapshot mode started (1 second interval)', 'camera');
            updateCameraSnapshot();
            streamInterval = setInterval(() => {
                if (cameraConnected) {
                    updateCameraSnapshot();
                } else {
                    stopStream();
                }
            }, 1000);
        }

        async function updateCameraSnapshot() {
            try {
                const frame = document.getElementById('cameraFrame');
                const response = await fetch(`${API_BASE}/api/camera/capture?t=${Date.now()}`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    if (frame.src && frame.src.startsWith('blob:')) {
                        URL.revokeObjectURL(frame.src);
                    }
                    frame.src = url;
                    frame.style.display = 'block';
                    const placeholder = document.getElementById('cameraPlaceholder');
                    if (placeholder) placeholder.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating camera snapshot:', error);
            }
        }

        function stopStream() {
            if (streamInterval) {
                clearInterval(streamInterval);
                streamInterval = null;
            }
            const frame = document.getElementById('cameraFrame');
            if (frame.src && frame.src.startsWith('blob:')) {
                URL.revokeObjectURL(frame.src);
            }
            frame.src = '';
            addSerialLog('Camera snapshot stopped', 'camera');
        }

        function startStreamImmediately() {
            const frame = document.getElementById('cameraFrame');
            frame.style.display = 'block';
            const placeholder = document.getElementById('cameraPlaceholder');
            if (placeholder) placeholder.style.display = 'none';
            addSerialLog('Starting camera snapshot mode (1 second interval)', 'camera');
            startStream();
        }

        function handleStreamLoad(imgElement) {
            const placeholder = document.getElementById('cameraPlaceholder');
            if (placeholder) placeholder.style.display = 'none';
            imgElement.style.display = 'block';
        }

        function handleStreamError(imgElement) {
            console.log('Snapshot error detected, will retry on next interval...');
            if (!cameraConnected) {
                const placeholder = document.getElementById('cameraPlaceholder');
                if (placeholder) placeholder.style.display = 'flex';
                imgElement.style.display = 'none';
            }
        }

        async function captureFrame() {
            try {
                addSerialLog('Capturing frame...', 'camera');
                const response = await fetch(`${API_BASE}/api/camera/capture?t=${Date.now()}`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `capture-${Date.now()}.jpg`;
                    link.click();
                    URL.revokeObjectURL(url);
                    addSerialLog('Frame captured and saved', 'success');
                } else {
                    addSerialLog('Frame capture failed', 'error');
                }
            } catch (error) {
                console.error('Error capturing frame:', error);
                addSerialLog(`Frame capture error: ${error.message}`, 'error');
                alert('Error capturing frame: ' + error.message);
            }
        }

        function toggleObjectDetection() {
            objectDetectionEnabled = topLevelObjectDetectionEnabled;
            if (objectDetectionEnabled) {
                addSerialLog('Object detection enabled', 'info');
            } else {
                addSerialLog('Object detection disabled', 'info');
            }
        }

        async function startObjectDetection() {
            if (objectDetectionActive) return;
            objectDetectionActive = true;
            const startBtn = document.getElementById('startObjectDetectionBtn');
            const stopBtn = document.getElementById('stopObjectDetectionBtn');
            const statsDiv = document.getElementById('objectDetectionStats');
            if (startBtn) startBtn.style.display = 'none';
            if (stopBtn) stopBtn.style.display = 'inline-flex';
            if (statsDiv) statsDiv.style.display = 'block';
            addSerialLog('Object detection started (continuous mode)', 'detection');
            const continuousCheckbox = document.getElementById('continuousObjectDetection');
            const continuous = continuousCheckbox ? continuousCheckbox.checked : true;
            await detectObjectsOnly();
            if (continuous) {
                objectDetectionInterval = setInterval(async () => {
                    if (objectDetectionActive && cameraConnected) {
                        await detectObjectsOnly();
                    }
                }, 1000);
            }
        }

        function stopObjectDetection() {
            objectDetectionActive = false;
            const startBtn = document.getElementById('startObjectDetectionBtn');
            const stopBtn = document.getElementById('stopObjectDetectionBtn');
            if (startBtn) startBtn.style.display = 'inline-flex';
            if (stopBtn) stopBtn.style.display = 'none';
            addSerialLog('Object detection stopped', 'detection');
            if (objectDetectionInterval) {
                clearInterval(objectDetectionInterval);
                objectDetectionInterval = null;
            }
        }

        let topLevelObjectDetectionEnabled = true;
        let topLevelDefectDetectionEnabled = true;
        let objectDetectionEnabled = true;
        const objectParams = Object.freeze({
            conf: 0.15,
            iou: 0.45,
            crop_top_percent: 0,
            crop_bottom_percent: 0
        });

        let detectionParams = {
            min_area: 500,
            max_area: 50000,
            blob_min_area: 500,
            blob_max_area: 20000,
            contour_min_area: 1000,
            contour_max_area: 50000,
            canny_low: 80,
            canny_high: 200,
            edge_canny_low: 60,
            edge_canny_high: 150,
            hough_threshold: 80,
            merge_threshold: 50,
            gaussian_blur: 7,
            adaptive_thresh_block: 15,
            adaptive_thresh_c: 5,
            min_line_length: 50,
            max_line_gap: 20,
            line_grouping_distance: 50,
            min_lines_per_defect: 3,
            min_edge_defect_size: 30,
            aspect_ratio_min: 0.3,
            aspect_ratio_max: 3.0,
            dilation_iterations: 1,
            morphological_kernel_size: 3
        };

        async function detectObjectsOnly() {
            try {
                // Check if PLC Start command is active before processing
                const configResponse = await fetch(`${API_BASE}/api/config`);
                const config = await configResponse.json();
                const db123Config = config.plc?.db123 || {};
                
                if (db123Config.enabled) {
                    // DB123 is enabled - check Start command
                    const tagsResponse = await fetch(`${API_BASE}/api/plc/db123/read`);
                    if (tagsResponse.ok) {
                        const tagsData = await tagsResponse.json();
                        const startCommand = tagsData.tags?.start || false;
                        
                        addSerialLog(`üîç Checking Start command: ${startCommand ? 'TRUE' : 'FALSE'}`, 'info');
                        
                        if (!startCommand) {
                            // Start command is False - skip detection
                            addSerialLog('‚è∏Ô∏è Detection skipped - PLC Start command not active', 'warning');
                            return;
                        }
                        
                        addSerialLog('‚úÖ Start command is TRUE - proceeding with detection', 'success');
                    } else {
                        // Can't read tags - skip to be safe
                        const errorText = await tagsResponse.text();
                        addSerialLog(`‚è∏Ô∏è Detection skipped - Cannot read PLC tags: ${tagsResponse.status} - ${errorText}`, 'warning');
                        return;
                    }
                } else {
                    addSerialLog('‚ÑπÔ∏è DB123 disabled - allowing detection (testing mode)', 'info');
                }
                // If DB123 is disabled, allow processing (for testing)
                
                const objectMethodElement = document.getElementById('objectDetectionMethod');
                const objectMethod = objectMethodElement ? objectMethodElement.value : 'circle';
                addSerialLog(`Running YOLO detection`, 'detection');
                addSerialLog(`  Params: Confidence=${objectParams.conf}, IOU=${objectParams.iou}`, 'info');
                const captureResponse = await fetch(`${API_BASE}/api/vision/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        method: 'combined',
                        params: detectionParams,
                        use_object_detection: true,
                        object_method: objectMethod,
                        object_params: objectParams,
                        defect_detection_enabled: false
                    })
                });
                
                if (captureResponse.status === 403) {
                    // Start command not active - backend rejected the request
                    const errorText = await captureResponse.text();
                    let errorData;
                    try {
                        errorData = JSON.parse(errorText);
                    } catch (e) {
                        errorData = { message: errorText };
                    }
                    addSerialLog(`‚è∏Ô∏è ${errorData.message || 'PLC Start command not active'}`, 'warning');
                    return;
                }
                
                if (!captureResponse.ok) {
                    addSerialLog(`Analysis API error: ${captureResponse.status}`, 'error');
                    return;
                }
                
                const blob = await captureResponse.blob();
                const url = URL.createObjectURL(blob);
                const analyzedImg = document.getElementById('analyzedImage');
                const analyzedPlaceholder = document.getElementById('analyzedPlaceholder');
                if (analyzedImg.src && analyzedImg.src.startsWith('blob:')) {
                    URL.revokeObjectURL(analyzedImg.src);
                }
                analyzedImg.src = url;
                analyzedImg.style.display = 'block';
                analyzedPlaceholder.style.display = 'none';
                const analyzedStatusIndicator = document.getElementById('analyzedStatusIndicator');
                const analyzedStatusText = document.getElementById('analyzedStatusText');
                if (analyzedStatusIndicator) analyzedStatusIndicator.classList.add('connected');
                if (analyzedStatusText) analyzedStatusText.textContent = 'Analysis Complete';
                
                const detectResponse = await fetch(`${API_BASE}/api/vision/detect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        object_detection_enabled: true,
                        defect_detection_enabled: false,
                        object_method: objectMethod,
                        object_params: objectParams
                    })
                });
                
                if (detectResponse.status === 403) {
                    // Start command not active - backend rejected the request
                    const errorText = await detectResponse.text();
                    let errorData;
                    try {
                        errorData = JSON.parse(errorText);
                    } catch (e) {
                        errorData = { message: errorText };
                    }
                    addSerialLog(`‚è∏Ô∏è ${errorData.message || 'PLC Start command not active'}`, 'warning');
                    return;
                }
                
                if (detectResponse.ok) {
                    const results = await detectResponse.json();
                    const objectCount = results.object_count || 0;
                    const objects = results.objects || [];
                    addSerialLog(`Detection results: ${objectCount} counters found`, 'detection');
                    
                    if (objects.length > 0) {
                        objects.forEach((obj, idx) => {
                            addSerialLog(`  Counter ${idx + 1}: center=(${obj.center[0]},${obj.center[1]}), radius=${obj.radius || 'N/A'}px, area=${obj.area?.toFixed(0) || 'N/A'}px¬≤, confidence=${(obj.confidence * 100).toFixed(0) || 'N/A'}%`, 'detection');
                        });
                    } else {
                        addSerialLog('  No counters detected - check camera view and lighting', 'warning');
                        addSerialLog(`  Model settings: Confidence=${objectParams.conf}, IOU=${objectParams.iou}`, 'info');
                    }
                    
                    const statsDiv = document.getElementById('objectDetectionStats');
                    if (statsDiv) statsDiv.style.display = 'block';
                    const countElement = document.getElementById('currentObjectCount');
                    const timeElement = document.getElementById('lastDetectionTime');
                    if (countElement) countElement.textContent = objectCount;
                    if (timeElement) timeElement.textContent = new Date().toLocaleTimeString();
                    if (countElement) {
                        if (objectCount === 4) {
                            countElement.style.color = '#10b981';
                        } else if (objectCount > 4) {
                            countElement.style.color = '#f59e0b';
                        } else {
                            countElement.style.color = '#ef4444';
                        }
                    }
                    updateCounterTimelineFromImages();
                    addSerialLog(`Counter detection complete: Found ${objectCount} counters`, objectCount > 0 ? 'info' : 'detection');
                } else {
                    const errorText = await detectResponse.text();
                    addSerialLog(`Detection API error: ${detectResponse.status} - ${errorText}`, 'error');
                }
            } catch (error) {
                console.error('Error in object detection:', error);
                addSerialLog(`Object detection error: ${error.message}`, 'error');
            }
        }

        async function startFullAnalysis() {
            addSerialLog('Full analysis is no longer available - use continuous object detection instead', 'info');
        }

        function stopFullAnalysis() {
            fullAnalysisActive = false;
            if (fullAnalysisInterval) {
                clearInterval(fullAnalysisInterval);
                fullAnalysisInterval = null;
            }
            addSerialLog('Full analysis stopped', 'info');
        }

        async function updateCounterTimelineFromImages() {
            const timelineList = document.getElementById('counterTimelineList');
            if (!timelineList) return;
            try {
                const response = await fetch(`${API_BASE}/api/counter-images`);
                const data = await response.json();
                if (data.error) {
                    timelineList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 12px; font-size: 11px;">No counters detected yet</div>';
                    return;
                }
                const images = data.images || [];
                if (images.length === 0) {
                    timelineList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 12px; font-size: 11px;">No counters detected yet</div>';
                    return;
                }
                const counterMap = {};
                images.forEach(img => {
                    const counterNum = img.counter_number;
                    if (!counterMap[counterNum] || new Date(img.timestamp) < new Date(counterMap[counterNum].timestamp)) {
                        counterMap[counterNum] = img;
                    }
                });
                const counterNumbers = Object.keys(counterMap).map(Number).sort((a, b) => a - b);
                timelineList.innerHTML = counterNumbers.map(counterNum => {
                    const img = counterMap[counterNum];
                    const date = new Date(img.timestamp * 1000);
                    const formattedTime = date.toLocaleString();
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
                            <span style="color: var(--primary-cyan); font-weight: 700; font-size: 12px;">Counter ${counterNum}</span>
                            <span style="color: var(--text-muted); font-size: 10px;">${formattedTime}</span>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Error updating counter timeline:', error);
                timelineList.innerHTML = '<div style="color: var(--accent-red); text-align: center; padding: 12px; font-size: 11px;">Error loading timeline</div>';
            }
        }

        async function deleteAllCounterImages() {
            if (!confirm('Are you sure you want to delete all counter images and reset the timeline? This cannot be undone.')) {
                return;
            }
            try {
                addSerialLog('Deleting all counter images and resetting timeline...', 'info');
                const response = await fetch(`${API_BASE}/api/counter-images/delete-all`, { method: 'POST' });
                const data = await response.json();
                if (data.error) {
                    addSerialLog(`Error deleting images: ${data.error}`, 'error');
                    alert(`Error: ${data.error}`);
                    return;
                }
                addSerialLog(`Successfully deleted ${data.deleted || 0} counter images and reset counter tracker`, 'success');
                await refreshCounterImages();
                await updateCounterTimelineFromImages();
                const defectResultsList = document.getElementById('defectResultsList');
                if (defectResultsList) {
                    defectResultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No defect analysis performed yet. Click "Analyze All" to check all counters.</div>';
                }
            } catch (error) {
                console.error('Error deleting counter images:', error);
                addSerialLog(`Error deleting images: ${error.message}`, 'error');
                alert(`Error: ${error.message}`);
            }
        }

        async function refreshCounterImages() {
            const imagesList = document.getElementById('counterImagesList');
            const statusDiv = document.getElementById('counterImagesStatus');
            if (!imagesList) return;
            try {
                if (counterImagesFirstLoad) {
                    imagesList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">Loading images...</div>';
                    if (statusDiv) statusDiv.textContent = '';
                } else if (statusDiv) {
                    statusDiv.textContent = 'Refreshing...';
                }
                const response = await fetch(`${API_BASE}/api/counter-images`);
                const data = await response.json();
                if (data.error) {
                    if (counterImagesFirstLoad) {
                        imagesList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">Error: ${data.error}</div>`;
                    }
                    if (statusDiv) statusDiv.textContent = `Error: ${data.error}`;
                    return;
                }
                const images = data.images || [];
                if (images.length === 0) {
                    imagesList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">No counter images saved yet</div>';
                    if (statusDiv) statusDiv.textContent = 'Waiting for new counter images...';
                    counterImagesFirstLoad = false;
                    loadStoredDefectResults();
                    return;
                }
                imagesList.innerHTML = images.map(img => {
                    return `
                        <div style="background: var(--card-bg); padding: 10px; border: 1px solid var(--border-color); cursor: pointer; transition: all 0.3s; clip-path: polygon(8px 0%, 100% 0%, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0% 100%, 0% 8px);" onclick="openImageModal('${img.url}')" onmouseover="this.style.borderColor='var(--primary-cyan)'" onmouseout="this.style.borderColor='var(--border-color)'">
                            <img src="${img.url}" alt="Counter ${img.counter_number}" style="width: 100%; height: 120px; object-fit: cover; margin-bottom: 8px;">
                            <div style="color: var(--primary-cyan); font-weight: 700; font-size: 10px; margin-bottom: 4px;">Counter ${img.counter_number}</div>
                            <div style="color: var(--text-muted); font-size: 9px;">${img.formatted_time}</div>
                        </div>
                    `;
                }).join('');
                addSerialLog(`Loaded ${images.length} counter images`, 'info');
                counterImagesFirstLoad = false;
                if (statusDiv) statusDiv.textContent = `Updated at ${new Date().toLocaleTimeString()}`;
                loadStoredDefectResults();
            } catch (error) {
                console.error('Error loading counter images:', error);
                if (counterImagesFirstLoad) {
                    imagesList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px; grid-column: 1 / -1;">Error loading images: ${error.message}</div>`;
                }
                if (statusDiv) statusDiv.textContent = `Error loading images: ${error.message}`;
            }
        }

        // Minimum thresholds for displaying defects (filter out false positives)
        const DEFECT_MIN_CONFIDENCE = 30;  // Minimum 30% confidence
        const DEFECT_MIN_COVERAGE = 5;     // Minimum 5% coverage
        
        async function loadStoredDefectResults() {
            const resultsList = document.getElementById('defectResultsList');
            if (!resultsList) return;
            try {
                addSerialLog('=== Loading Stored Defect Results ===', 'detection');
                addSerialLog(`Thresholds: Min Confidence=${DEFECT_MIN_CONFIDENCE}%, Min Coverage=${DEFECT_MIN_COVERAGE}%`, 'info');
                
                // First, get the list of actual saved counter images
                const imagesResponse = await fetch(`${API_BASE}/api/counter-images`);
                const imagesData = await imagesResponse.json();
                const savedCounterNumbers = new Set();
                if (imagesData.images && imagesData.images.length > 0) {
                    imagesData.images.forEach(img => savedCounterNumbers.add(img.counter_number));
                }
                
                addSerialLog(`Saved counter images: [${[...savedCounterNumbers].sort((a,b) => a-b).join(', ')}] (${savedCounterNumbers.size} total)`, 'info');
                
                // If no saved images, don't show any defect results
                if (savedCounterNumbers.size === 0) {
                    addSerialLog('No saved images found - skipping defect display', 'warning');
                    resultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No counter images to analyze</div>';
                    return;
                }
                
                // Now get the defect results
                const response = await fetch(`${API_BASE}/api/counter-images/defects`);
                const data = await response.json();
                if (data.error) {
                    addSerialLog(`Defect API error: ${data.error}`, 'error');
                    resultsList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px;">Error loading defect results: ${data.error}</div>`;
                    return;
                }
                const defects = data.defects || [];
                addSerialLog(`Raw defect results from API: ${defects.length} entries`, 'info');
                
                if (defects.length === 0) {
                    addSerialLog('No defect analysis data in storage', 'info');
                    resultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No defect analysis results yet</div>';
                    return;
                }
                
                // Log all raw defect data for debugging
                addSerialLog('--- Raw Defect Data ---', 'detection');
                defects.forEach(result => {
                    const defectData = result.defect_results || {};
                    const confidence = defectData.confidence || 0;
                    const coverage = defectData.total_defect_area_percentage || 0;
                    const defectsFound = defectData.defects_found || false;
                    const hasImage = savedCounterNumbers.has(result.counter_number);
                    
                    addSerialLog(`  Counter ${result.counter_number}: defects_found=${defectsFound}, confidence=${confidence.toFixed(1)}%, coverage=${coverage.toFixed(1)}%, has_saved_image=${hasImage}`, 'info');
                    
                    if (defectData.defects && defectData.defects.length > 0) {
                        defectData.defects.forEach((d, i) => {
                            addSerialLog(`    Defect ${i+1}: area=${(d.area_percentage || 0).toFixed(1)}%, color_diff=${d.color_difference || 0}`, 'info');
                        });
                    }
                });
                
                // Filter defects to only include:
                // 1. Counters that have saved images
                // 2. Defects with confidence >= DEFECT_MIN_CONFIDENCE
                // 3. Defects with coverage >= DEFECT_MIN_COVERAGE
                addSerialLog('--- Filtering Results ---', 'detection');
                const validDefects = defects.filter(result => {
                    const counterNum = result.counter_number;
                    const defectData = result.defect_results || {};
                    const confidence = defectData.confidence || 0;
                    const coverage = defectData.total_defect_area_percentage || 0;
                    
                    // Must have a saved image
                    if (!savedCounterNumbers.has(counterNum)) {
                        addSerialLog(`  Counter ${counterNum}: FILTERED - no saved image`, 'warning');
                        return false;
                    }
                    
                    if (!defectData.defects_found) {
                        addSerialLog(`  Counter ${counterNum}: SKIPPED - no defects detected by backend`, 'info');
                        return false;
                    }
                    
                    // Check confidence threshold
                    if (confidence < DEFECT_MIN_CONFIDENCE) {
                        addSerialLog(`  Counter ${counterNum}: FILTERED - confidence ${confidence.toFixed(1)}% < ${DEFECT_MIN_CONFIDENCE}% threshold`, 'warning');
                        return false;
                    }
                    
                    // Check coverage threshold
                    if (coverage < DEFECT_MIN_COVERAGE) {
                        addSerialLog(`  Counter ${counterNum}: FILTERED - coverage ${coverage.toFixed(1)}% < ${DEFECT_MIN_COVERAGE}% threshold`, 'warning');
                        return false;
                    }
                    
                    addSerialLog(`  Counter ${counterNum}: PASSED - showing defect (conf=${confidence.toFixed(1)}%, cov=${coverage.toFixed(1)}%)`, 'success');
                    return true;
                });
                
                addSerialLog(`Final: ${validDefects.length} of ${defects.length} defects passed filters`, 'detection');
                
                if (validDefects.length === 0) {
                    addSerialLog('No defects passed thresholds - all counters appear good', 'success');
                    resultsList.innerHTML = '<div style="color: var(--accent-green); text-align: center; padding: 24px; font-size: 11px;">‚úì No significant defects found - all counters are good!</div>';
                    return;
                }
                
                resultsList.innerHTML = validDefects
                    .sort((a, b) => a.counter_number - b.counter_number)
                    .map(result => {
                        const data = result.defect_results || {};
                        return `
                            <div style="background: var(--card-bg); padding: 12px; margin-bottom: 10px; border-left: 3px solid var(--accent-red); border: 1px solid var(--border-color); clip-path: polygon(8px 0%, 100% 0%, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0% 100%, 0% 8px);">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <div style="color: var(--primary-cyan); font-weight: 700; font-size: 11px;">Counter ${result.counter_number}</div>
                                    <div style="color: var(--accent-red); font-weight: 700; font-size: 10px;">DEFECT FOUND</div>
                                </div>
                                <div style="color: var(--text-secondary); font-size: 10px;">
                                    Coverage: ${data.total_defect_area_percentage ? data.total_defect_area_percentage.toFixed(1) : '0'}% | Confidence: ${data.confidence ? data.confidence.toFixed(1) : '0.0'}%
                                </div>
                            </div>
                        `;
                    }).join('');
            } catch (error) {
                console.error('Error loading stored defect results:', error);
                resultsList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px;">Error loading defect results: ${error.message}</div>`;
            }
        }

        function openImageModal(imageUrl) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 0, 21, 0.95); z-index: 10000; display: flex; align-items: center; justify-content: center; cursor: pointer;';
            modal.onclick = () => document.body.removeChild(modal);
            const img = document.createElement('img');
            img.src = imageUrl;
            img.style.cssText = 'max-width: 90%; max-height: 90%; object-fit: contain; border: 2px solid var(--border-color);';
            img.onclick = (e) => e.stopPropagation();
            modal.appendChild(img);
            document.body.appendChild(modal);
        }

        async function analyzeAllCountersForDefects() {
            const resultsList = document.getElementById('defectResultsList');
            if (!resultsList) return;
            try {
                addSerialLog('=== ANALYZE ALL COUNTERS FOR DEFECTS ===', 'detection');
                addSerialLog(`Thresholds: Min Confidence=${DEFECT_MIN_CONFIDENCE}%, Min Coverage=${DEFECT_MIN_COVERAGE}%`, 'info');
                
                resultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">Analyzing counters for defects...</div>';
                const imagesResponse = await fetch(`${API_BASE}/api/counter-images`);
                const imagesData = await imagesResponse.json();
                if (imagesData.error || !imagesData.images || imagesData.images.length === 0) {
                    addSerialLog('No counter images found to analyze', 'warning');
                    resultsList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 24px; font-size: 11px;">No counter images to analyze</div>';
                    return;
                }
                
                addSerialLog(`Found ${imagesData.images.length} counter images to analyze`, 'info');
                
                const analysisResults = [];
                for (const img of imagesData.images) {
                    try {
                        addSerialLog(`Analyzing Counter ${img.counter_number}...`, 'detection');
                        const response = await fetch(`${API_BASE}/api/counter-images/${img.counter_number}/analyze-defects`, { method: 'POST' });
                        const result = await response.json();
                        result.counter_number = img.counter_number;
                        analysisResults.push(result);
                        
                        // Log detailed results
                        const confidence = result.confidence || 0;
                        const coverage = result.total_defect_area_percentage || 0;
                        const defectCount = result.defect_count || 0;
                        
                        addSerialLog(`  Counter ${img.counter_number} result:`, 'info');
                        addSerialLog(`    defects_found: ${result.defects_found}`, 'info');
                        addSerialLog(`    defect_count: ${defectCount}`, 'info');
                        addSerialLog(`    confidence: ${confidence.toFixed(1)}%`, 'info');
                        addSerialLog(`    coverage: ${coverage.toFixed(1)}%`, 'info');
                        
                        if (result.defects && result.defects.length > 0) {
                            result.defects.forEach((d, i) => {
                                addSerialLog(`    Defect ${i+1}: area=${(d.area_percentage || 0).toFixed(1)}%, color_diff=${d.color_difference || 0}, center=(${d.center_x || 0},${d.center_y || 0})`, 'info');
                            });
                        }
                        
                        // Log raw API response for deep debugging
                        addSerialLog(`    Raw API response keys: ${Object.keys(result).join(', ')}`, 'info');
                        
                    } catch (error) {
                        console.error(`Error analyzing counter ${img.counter_number}:`, error);
                        addSerialLog(`  Counter ${img.counter_number}: ERROR - ${error.message}`, 'error');
                        analysisResults.push({ counter_number: img.counter_number, error: error.message });
                    }
                }
                
                // Filter to only show significant defects (above thresholds)
                addSerialLog('--- Filtering Results ---', 'detection');
                const significantDefects = analysisResults.filter(result => {
                    const counterNum = result.counter_number;
                    
                    if (result.error) {
                        addSerialLog(`  Counter ${counterNum}: FILTERED - analysis error`, 'error');
                        return false;
                    }
                    
                    if (!result.defects_found) {
                        addSerialLog(`  Counter ${counterNum}: SKIPPED - no defects detected by backend`, 'info');
                        return false;
                    }
                    
                    const confidence = result.confidence || 0;
                    const coverage = result.total_defect_area_percentage || 0;
                    
                    if (confidence < DEFECT_MIN_CONFIDENCE) {
                        addSerialLog(`  Counter ${counterNum}: FILTERED - confidence ${confidence.toFixed(1)}% < ${DEFECT_MIN_CONFIDENCE}% threshold`, 'warning');
                        return false;
                    }
                    
                    if (coverage < DEFECT_MIN_COVERAGE) {
                        addSerialLog(`  Counter ${counterNum}: FILTERED - coverage ${coverage.toFixed(1)}% < ${DEFECT_MIN_COVERAGE}% threshold`, 'warning');
                        return false;
                    }
                    
                    addSerialLog(`  Counter ${counterNum}: PASSED - showing defect (conf=${confidence.toFixed(1)}%, cov=${coverage.toFixed(1)}%)`, 'success');
                    return true;
                });
                
                addSerialLog(`=== SUMMARY ===`, 'detection');
                addSerialLog(`Total analyzed: ${analysisResults.length}`, 'info');
                addSerialLog(`Passed filters: ${significantDefects.length}`, 'info');
                addSerialLog(`Filtered out: ${analysisResults.length - significantDefects.length}`, 'info');
                
                if (significantDefects.length === 0) {
                    resultsList.innerHTML = '<div style="color: var(--accent-green); text-align: center; padding: 24px; font-size: 11px;">‚úì No significant defects found - all counters are good!</div>';
                    addSerialLog(`No significant defects passed thresholds`, 'success');
                    return;
                }
                
                resultsList.innerHTML = significantDefects
                    .sort((a, b) => a.counter_number - b.counter_number)
                    .map(result => {
                        return `
                            <div style="background: var(--card-bg); padding: 12px; margin-bottom: 10px; border-left: 3px solid var(--accent-red); border: 1px solid var(--border-color); clip-path: polygon(8px 0%, 100% 0%, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0% 100%, 0% 8px);">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <div style="color: var(--primary-cyan); font-weight: 700; font-size: 11px;">Counter ${result.counter_number}</div>
                                    <div style="color: var(--accent-red); font-weight: 700; font-size: 10px;">DEFECT FOUND</div>
                                </div>
                                <div style="color: var(--text-secondary); font-size: 10px;">
                                    Coverage: ${result.total_defect_area_percentage ? result.total_defect_area_percentage.toFixed(1) : '0'}% | Confidence: ${(result.confidence || 0).toFixed(1)}%
                                </div>
                            </div>
                        `;
                    }).join('');
                addSerialLog(`${significantDefects.length} counters with significant defects displayed`, 'detection');
            } catch (error) {
                console.error('Error analyzing counters for defects:', error);
                addSerialLog(`Fatal error in defect analysis: ${error.message}`, 'error');
                resultsList.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 24px; font-size: 11px;">Error: ${error.message}</div>`;
            }
        }

        function toggleInfoPanel() {
            const content = document.getElementById('infoContent');
            const icon = document.getElementById('infoToggleIcon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        function toggleFullscreen() {
            const frame = document.getElementById('cameraFrame');
            if (!frame.src) return;
            if (!document.fullscreenElement) {
                frame.requestFullscreen().catch(err => alert('Error entering fullscreen: ' + err.message));
            } else {
                document.exitFullscreen();
            }
        }

        // Camera Crop/Zoom Functions
        async function loadCropSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/camera/crop`);
                if (response.ok) {
                    const crop = await response.json();
                    document.getElementById('cropEnabled').checked = crop.enabled;
                    document.getElementById('cropX').value = crop.x;
                    document.getElementById('cropY').value = crop.y;
                    document.getElementById('cropWidth').value = crop.width;
                    document.getElementById('cropHeight').value = crop.height;
                    
                    toggleCrop();
                    updateCropPreview();
                }
            } catch (error) {
                console.error('Error loading crop settings:', error);
            }
        }
        
        function toggleCrop() {
            const enabled = document.getElementById('cropEnabled').checked;
            const controls = document.getElementById('cropControls');
            controls.style.display = enabled ? 'grid' : 'none';
            if (!enabled) {
                // Reset to full frame when disabled
                document.getElementById('cropX').value = 0;
                document.getElementById('cropY').value = 0;
                document.getElementById('cropWidth').value = 100;
                document.getElementById('cropHeight').value = 100;
                updateCropPreview();
            }
        }
        
        function updateCropPreview() {
            const x = document.getElementById('cropX').value;
            const y = document.getElementById('cropY').value;
            const width = document.getElementById('cropWidth').value;
            const height = document.getElementById('cropHeight').value;
            
            document.getElementById('cropXValue').textContent = x + '%';
            document.getElementById('cropYValue').textContent = y + '%';
            document.getElementById('cropWidthValue').textContent = width + '%';
            document.getElementById('cropHeightValue').textContent = height + '%';
        }
        
        async function saveCropSettings() {
            try {
                const enabled = document.getElementById('cropEnabled').checked;
                const x = parseFloat(document.getElementById('cropX').value);
                const y = parseFloat(document.getElementById('cropY').value);
                const width = parseFloat(document.getElementById('cropWidth').value);
                const height = parseFloat(document.getElementById('cropHeight').value);
                
                const response = await fetch(`${API_BASE}/api/camera/crop`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled, x, y, width, height })
                });
                
                if (response.ok) {
                    addSerialLog('‚úÖ Crop settings saved successfully', 'success');
                    // Force refresh camera feed
                    if (cameraConnected) {
                        updateCameraSnapshot();
                    }
                } else {
                    const error = await response.json();
                    addSerialLog(`‚ùå Error saving crop: ${error.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Error saving crop settings:', error);
                addSerialLog(`‚ùå Error saving crop: ${error.message}`, 'error');
            }
        }
        
        function openCameraSettings() {
            const adjustments = document.getElementById('imageAdjustments');
            if (adjustments.style.display === 'none') {
                adjustments.style.display = 'block';
            } else {
                adjustments.style.display = 'none';
            }
        }

        function updateImageAdjustments() {
            const brightness = document.getElementById('brightnessSlider').value;
            const contrast = document.getElementById('contrastSlider').value;
            const frame = document.getElementById('cameraFrame');
            document.getElementById('brightnessValue').textContent = brightness;
            document.getElementById('contrastValue').textContent = contrast;
            const brightnessValue = parseFloat(brightness) / 100;
            const contrastValue = (parseFloat(contrast) + 100) / 100;
            frame.style.filter = `brightness(${1 + brightnessValue}) contrast(${contrastValue})`;
        }

        function resetImageAdjustments() {
            document.getElementById('brightnessSlider').value = 0;
            document.getElementById('contrastSlider').value = 0;
            document.getElementById('brightnessValue').textContent = '0';
            document.getElementById('contrastValue').textContent = '0';
            const frame = document.getElementById('cameraFrame');
            frame.style.filter = 'none';
        }

        function loadDetectionParams() {
            const saved = localStorage.getItem('detectionParams');
            if (saved) {
                try {
                    detectionParams = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading detection params:', e);
                }
            }
        }

        function toggleSerialMonitor() {
            const monitor = document.getElementById('serialMonitor');
            const icon = document.getElementById('serialMonitorToggleIcon');
            if (monitor.style.display === 'none') {
                monitor.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                monitor.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        let serialLogEntries = [];
        const MAX_LOG_ENTRIES = 500;

        function addSerialLog(message, type = 'info') {
            const now = new Date();
            serialLogEntries.push({ message, type, timestamp: now });
            if (serialLogEntries.length > MAX_LOG_ENTRIES) {
                serialLogEntries.shift();
            }
            updateSerialLogDisplay();
        }

        function updateSerialLogDisplay() {
            const logDiv = document.getElementById('serialLog');
            if (!logDiv) return;
            
            // Store scroll position BEFORE updating content
            const autoScrollEnabled = document.getElementById('autoScrollLog')?.checked ?? true;
            const previousScrollTop = logDiv.scrollTop;
            const previousScrollHeight = logDiv.scrollHeight;
            
            const timestamp = document.getElementById('timestampLog')?.checked ?? true;
            const colors = {
                'info': '#00ffff',
                'warning': '#f59e0b',
                'error': '#ef4444',
                'success': '#10b981',
                'camera': '#22d3ee',
                'detection': '#ff00ff',
                'plc': '#f97316'
            };
            let html = '';
            serialLogEntries.forEach(entry => {
                const timeStr = timestamp ? `[${entry.timestamp.toLocaleTimeString()}.${String(entry.timestamp.getMilliseconds()).padStart(3, '0')}] ` : '';
                const color = colors[entry.type] || '#a1a1aa';
                html += `<div style="color: ${color};">${timeStr}${entry.message}</div>`;
            });
            logDiv.innerHTML = html || '<div style="color: var(--text-muted);">No log entries</div>';
            
            // Restore scroll position AFTER content update
            if (autoScrollEnabled) {
                // Auto-scroll: always go to bottom
                setTimeout(() => {
                    logDiv.scrollTop = logDiv.scrollHeight;
                }, 10);
            } else {
                // Manual scroll: preserve exact scroll position (don't move user)
                // Calculate the ratio of scroll position to maintain relative position
                const scrollRatio = previousScrollHeight > 0 ? previousScrollTop / previousScrollHeight : 0;
                setTimeout(() => {
                    // Restore to same relative position, but clamp to valid range
                    const newScrollTop = Math.min(
                        logDiv.scrollHeight * scrollRatio,
                        logDiv.scrollHeight - logDiv.clientHeight
                    );
                    logDiv.scrollTop = Math.max(0, newScrollTop);
                }, 10);
            }
        }

        function clearSerialLog(event) {
            if (event) event.stopPropagation();
            serialLogEntries = [];
            updateSerialLogDisplay();
            addSerialLog('Serial monitor cleared', 'info');
        }

        // DB123 Configuration Functions
        async function loadDb123Config() {
            try {
                const response = await fetch(`${API_BASE}/api/config`);
                const config = await response.json();
                const db123Config = config.plc?.db123 || {};
                
                const enabledCheckbox = document.getElementById('db123Enabled');
                const dbNumberInput = document.getElementById('db123Number');
                const statusDiv = document.getElementById('db123Status');
                
                if (enabledCheckbox) {
                    enabledCheckbox.checked = db123Config.enabled || false;
                }
                if (dbNumberInput) {
                    dbNumberInput.value = db123Config.db_number || 123;
                }
                
                updateDb123Status();
            } catch (error) {
                console.error('Error loading DB123 config:', error);
                addSerialLog(`Error loading DB123 config: ${error.message}`, 'error');
            }
        }

        async function saveDb123Config() {
            try {
                const enabledCheckbox = document.getElementById('db123Enabled');
                const dbNumberInput = document.getElementById('db123Number');
                
                const enabled = enabledCheckbox ? enabledCheckbox.checked : false;
                const dbNumber = dbNumberInput ? parseInt(dbNumberInput.value) : 123;
                
                if (isNaN(dbNumber) || dbNumber < 1 || dbNumber > 65535) {
                    alert('DB Number must be between 1 and 65535');
                    return;
                }
                
                addSerialLog('Saving DB123 configuration...', 'info');
                
                const response = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        plc: {
                            db123: {
                                enabled: enabled,
                                db_number: dbNumber
                            }
                        }
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    addSerialLog('DB123 configuration saved successfully', 'success');
                    updateDb123Status();
                    alert('DB123 configuration saved successfully!');
                } else {
                    addSerialLog(`Error saving DB123 config: ${result.error || 'Unknown error'}`, 'error');
                    alert(`Error: ${result.error || 'Failed to save configuration'}`);
                }
            } catch (error) {
                console.error('Error saving DB123 config:', error);
                addSerialLog(`Error saving DB123 config: ${error.message}`, 'error');
                alert(`Error saving configuration: ${error.message}`);
            }
        }

        async function updateDb123Status() {
            const statusDiv = document.getElementById('db123Status');
            if (!statusDiv) return;
            
            try {
                const configResponse = await fetch(`${API_BASE}/api/config`);
                const config = await configResponse.json();
                const db123Config = config.plc?.db123 || {};
                const enabled = db123Config.enabled || false;
                const dbNumber = db123Config.db_number || 123;
                
                // Get PLC connection status from API
                let plcConnected = false;
                try {
                    const plcStatusResponse = await fetch(`${API_BASE}/api/plc/status`);
                    const plcStatus = await plcStatusResponse.json();
                    plcConnected = plcStatus.connected || false;
                } catch (e) {
                    // If PLC status endpoint fails, assume disconnected
                    plcConnected = false;
                }
                
                if (enabled) {
                    statusDiv.innerHTML = `
                        <div style="color: var(--accent-green);">‚úì DB123 Communication: ENABLED</div>
                        <div style="color: var(--text-secondary); margin-top: 4px;">DB Number: ${dbNumber}</div>
                        <div style="color: ${plcConnected ? 'var(--accent-green)' : 'var(--accent-red)'}; margin-top: 4px;">
                            PLC Connection: ${plcConnected ? 'Connected' : 'Disconnected'}
                        </div>
                    `;
                } else {
                    statusDiv.innerHTML = `
                        <div style="color: var(--text-muted);">DB123 Communication: DISABLED</div>
                        <div style="color: var(--text-secondary); margin-top: 4px; font-size: 9px;">Enable the checkbox above to start writing to PLC</div>
                    `;
                }
            } catch (error) {
                statusDiv.innerHTML = `<div style="color: var(--accent-red);">Error loading status: ${error.message}</div>`;
            }
        }

        // Update status every 5 seconds
        setInterval(updateDb123Status, 5000);
        
        // Update PLC tags every 2 seconds
        setInterval(updatePlcTagsStatus, 2000);
        
        // Update PLC Start status banner every 2 seconds
        setInterval(updatePlcStartStatusBanner, 2000);

        // PLC Connection Functions
        async function connectToPLC() {
            try {
                addSerialLog('Attempting to connect to PLC...', 'plc');
                const response = await fetch(`${API_BASE}/api/plc/connect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();
                
                if (result.success && result.connected) {
                    addSerialLog('‚úì PLC connected successfully', 'success');
                    updateDb123Status();
                    updatePlcTagsStatus();
                    alert('PLC connected successfully!');
                } else {
                    addSerialLog(`‚úó PLC connection failed: ${result.error || 'Unknown error'}`, 'error');
                    alert(`PLC connection failed: ${result.error || 'Unknown error'}\n\nCheck:\n- PLC is powered on\n- Network connectivity (ping 192.168.7.2)\n- PLC PUT/GET communication is enabled in TIA Portal`);
                }
            } catch (error) {
                console.error('Error connecting to PLC:', error);
                addSerialLog(`PLC connection error: ${error.message}`, 'error');
                alert(`Error connecting to PLC: ${error.message}`);
            }
        }

        // PLC Tags Status Functions
        async function updatePlcTagsStatus() {
            const tagsDiv = document.getElementById('plcTagsStatus');
            if (!tagsDiv) return;
            
            try {
                const response = await fetch(`${API_BASE}/api/plc/db123/read`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                if (data.error) {
                    tagsDiv.innerHTML = `
                        <div style="color: var(--accent-red); text-align: center; padding: 12px; grid-column: 1 / -1;">
                            Error: ${data.error}
                        </div>
                    `;
                    return;
                }
                
                const tags = data.tags || {};
                
                // Helper function to format boolean values
                const formatBool = (value) => {
                    if (value === true || value === 1) {
                        return '<span style="color: var(--accent-green); font-weight: 700;">TRUE</span>';
                    } else {
                        return '<span style="color: var(--text-muted);">FALSE</span>';
                    }
                };
                
                tagsDiv.innerHTML = `
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Start</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${formatBool(tags.start)}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.0</div>
                    </div>
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Connected</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${formatBool(tags.connected)}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.1</div>
                    </div>
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Busy</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${formatBool(tags.busy)}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.2</div>
                    </div>
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Completed</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${formatBool(tags.completed)}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.3</div>
                    </div>
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Object_Detected</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${formatBool(tags.object_detected)}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.4</div>
                    </div>
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Object_OK</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${formatBool(tags.object_ok)}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.5</div>
                    </div>
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Defect_Detected</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${formatBool(tags.defect_detected)}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBX40.6</div>
                    </div>
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Object_Number</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${tags.object_number || 0}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBW42</div>
                    </div>
                    <div style="padding: 8px; background: var(--bg-panel); border: 1px solid var(--border-color); clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);">
                        <div style="color: var(--text-secondary); font-size: 9px; margin-bottom: 4px;">Defect_Number</div>
                        <div style="color: var(--primary-cyan); font-size: 11px; font-weight: 700;">${tags.defect_number || 0}</div>
                        <div style="color: var(--text-muted); font-size: 8px; margin-top: 2px;">DB123.DBW44</div>
                    </div>
                `;
            } catch (error) {
                console.error('Error updating PLC tags status:', error);
                tagsDiv.innerHTML = `
                    <div style="color: var(--accent-red); text-align: center; padding: 12px; grid-column: 1 / -1;">
                        Error loading tags: ${error.message}
                    </div>
                `;
            }
        }

        async function refreshPlcTags() {
            addSerialLog('Refreshing PLC tag status...', 'plc');
            await updatePlcTagsStatus();
        }

        // PLC Start Status Banner Functions
        async function updatePlcStartStatusBanner() {
            const banner = document.getElementById('plcStartStatusBanner');
            const indicator = document.getElementById('plcStartIndicator');
            const statusText = document.getElementById('plcStartStatusText');
            
            if (!banner || !indicator || !statusText) return;
            
            try {
                const configResponse = await fetch(`${API_BASE}/api/config`);
                const config = await configResponse.json();
                const db123Config = config.plc?.db123 || {};
                
                if (!db123Config.enabled) {
                    // DB123 disabled - hide banner or show disabled message
                    banner.style.display = 'none';
                    return;
                }
                
                banner.style.display = 'block';
                
                // Get PLC connection status
                let plcConnected = false;
                try {
                    const plcStatusResponse = await fetch(`${API_BASE}/api/plc/status`);
                    const plcStatus = await plcStatusResponse.json();
                    plcConnected = plcStatus.connected || false;
                } catch (e) {
                    plcConnected = false;
                }
                
                if (!plcConnected) {
                    indicator.classList.remove('connected');
                    statusText.innerHTML = '<span style="color: var(--accent-red);">‚ö†Ô∏è PLC Not Connected - Cannot read Start command</span>';
                    banner.style.borderLeft = '4px solid var(--accent-red)';
                    return;
                }
                
                // Get Start command status
                const tagsResponse = await fetch(`${API_BASE}/api/plc/db123/read`);
                if (!tagsResponse.ok) {
                    indicator.classList.remove('connected');
                    statusText.innerHTML = '<span style="color: var(--accent-orange);">‚ö†Ô∏è Cannot read Start command from PLC</span>';
                    banner.style.borderLeft = '4px solid var(--accent-orange)';
                    return;
                }
                
                const tagsData = await tagsResponse.json();
                const startCommand = tagsData.tags?.start || false;
                
                if (startCommand) {
                    // Start command is active
                    indicator.classList.add('connected');
                    statusText.innerHTML = '<span style="color: var(--accent-green);">‚úì Start Command ACTIVE - Vision processing enabled</span>';
                    banner.style.borderLeft = '4px solid var(--accent-green)';
                } else {
                    // Start command is not active
                    indicator.classList.remove('connected');
                    statusText.innerHTML = '<span style="color: var(--primary-cyan);">‚è∏Ô∏è Awaiting Start command from PLC</span>';
                    banner.style.borderLeft = '4px solid var(--primary-cyan)';
                }
            } catch (error) {
                console.error('Error updating PLC Start status banner:', error);
                indicator.classList.remove('connected');
                statusText.innerHTML = `<span style="color: var(--accent-red);">‚ö†Ô∏è Error: ${error.message}</span>`;
                banner.style.borderLeft = '4px solid var(--accent-red)';
            }
        }
    </script>
</body>
</html>

